{"version":3,"sources":["vs/workbench/contrib/output/common/fake","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/async.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/process.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/path.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/extpath.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/map.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/glob.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/network.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/resources.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/workbench/contrib/output/common/outputLinkComputer.ts"],"names":["__m","__M","deps","result","i","len","length","isThenable","obj","then","createCancelablePromise","callback","source","cancellation_1","CancellationTokenSource","thenable","token","promise","Promise","resolve","reject","onCancellationRequested","errors","canceled","value","dispose","err","[object Object]","cancel","this","undefined","onfinally","finally","exports","raceCancellation","defaultValue","race","asPromise","item","Throttler","activePromise","queuedPromise","queuedPromiseFactory","promiseFactory","onComplete","queue","c","e","Sequencer","current","promiseTask","Delayer","defaultDelay","timeout","completionPromise","doResolve","doReject","task","delay","cancelTimeout","setTimeout","clearTimeout","ThrottledDelayer","delayer","throttler","trigger","isTriggered","millis","handle","Barrier","_isOpen","_promise","_completePromise","disposableTimeout","handler","timer","lifecycle_1","toDisposable","ignoreErrors","_","sequence","promiseFactories","results","index","thenHandler","push","n","first","shouldStop","t","loop","factory","Limiter","maxDegreeOfParalellism","_size","outstandingPromises","runningPromises","_onFinished","event_1","Emitter","onFinished","event","size","consume","iLimitedTask","shift","consumed","fire","Queue","super","ResourceQueue","queues","Map","resource","key","toString","has","delete","set","get","forEach","clear","TimeoutTimer","runner","_token","setIfNotSet","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","onTimeout","bind","isScheduled","doRun","RunOnceWorker","units","unit","schedule","requestIdleCallback","cancelIdleCallback","dummyIdle","Object","freeze","didTimeout","timeRemaining","runWhenIdle","disposed","IdleValue","executor","_didRun","_executor","_value","_error","_handle","retry","async","retries","lastError","error","safeProcess","process","cwd","env","create","platform","platform_1","isWindows","isMacintosh","nextTick","setImmediate","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_DOT","CHAR_FORWARD_SLASH","CHAR_BACKWARD_SLASH","ErrorInvalidArgType","Error","name","expected","actual","determiner","indexOf","replace","type","msg","code","validateString","isPathSeparator","isPosixPathSeparator","isWindowsDeviceRoot","normalizeString","path","allowAboveRoot","separator","res","lastSegmentLength","lastSlash","dots","charCodeAt","lastSlashIndex","lastIndexOf","slice","_format","sep","pathObject","dir","root","base","ext","win32","pathSegments","resolvedDevice","resolvedTail","resolvedAbsolute","toLowerCase","rootEnd","device","isAbsolute","j","last","firstPart","tail","paths","joined","arg","needsReplace","slashCount","firstLen","normalize","from","to","fromOrig","toOrig","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","out","resolvedPath","end","matchedSlash","offset","start","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","ret","delimiter","posix","trailingSeparator","arguments","toNamespacedPath","hasRoot","join","relative","dirname","basename","extname","format","parse","toSlashes","osPath","path_1","getRoot","firstLetter","pos","isWindowsDriveLetter","isUNC","isNaN","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","char0","isValidBasename","isWindowsOS","invalidFileChars","test","lastIndex","trim","isEqual","pathA","pathB","ignoreCase","identityEquals","strings_1","equalsIgnoreCase","isEqualOrParent","candidate","startsWithIgnoreCase","sepOffset","charAt","sanitizeFilePath","endsWith","rtrim","isRootOrDriveLetter","pathNormalized","values","forEachable","keys","map","getOrSet","mapToString","entries","setToString","mapToSerializable","serializable","serializableToMap","items","StringIterator","_pos","a","PathIterator","_splitOnBackslash","_from","_to","next","justSeps","ch","aPos","aLen","thisPos","cmp","substring","TernarySearchTreeNode","left","mid","right","TernarySearchTree","segments","_iter","_root","element","iter","reset","node","segment","val","hasNext","oldElement","stack","isEmpty","parent","pop","_nodeIterator","idx","data","_forEach","iterator_1","FIN","done","ResourceMap","toKey","clb","uri_1","URI","k","resourceMap","Touch","LinkedMap","_map","_head","_tail","_a","touch","previous","addItemLast","addItemFirst","remove","removeItem","callbackfn","thisArg","newSize","currentSize","LRUCache","limit","ratio","_limit","_ratio","Math","min","max","checkTrim","trimOld","round","getEmptyExpression","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","splitGlobAware","pattern","splitChar","inBraces","inBrackets","curVal","char","T1","T2","T3","T3_2","T4","T5","CACHE","map_1","FALSE","NULL","parsePattern","arg1","options","patternKey","trimForExclusions","match","parsedPattern","wrapRelativePattern","substr","strings","exec","originalPattern","slashBase","backslashBase","basenames","patterns","allBasenames","trivia2","parsedPatterns","aggregateBasenameMatches","split","filter","withBasenames","arrays","allPaths","reduce","all","concat","trivia3","trivia4and5","regExp","RegExp","parseRegExp","regEx","every","s","previousSegmentWasGlobStar","braceVal","bracketVal","braceRegExp","escapeRegExpCharacters","toRegExp","arg2","extpath","matchPathEnds","nativePath","nativePathEnd","isRelativePattern","resultPattern","expression","getOwnPropertyNames","when","hasSibling","matched","async_1","m","requiresSiblings","parseExpressionPattern","some","resultExpression","parsedExpression","listToMap","list","rp","basenamePatterns","aggregate","aggregatedPatterns","hasSiblingPromiseFn","siblingsFn","siblings","hasSiblingFn","getBasenameTerms","patternOrExpression","getPathTerms","Schemas","inMemory","vscode","internal","walkThrough","walkThroughSnippet","http","https","file","mailto","untitled","command","vscodeRemote","vscodeRemoteResource","userData","RemoteAuthorities","_hosts","_ports","_connectionTokens","_preferredWebSchema","_delegate","schema","delegate","authority","host","port","connectionToken","uri","query","encodeURIComponent","scheme","isWeb","window","location","pathname","hasToIgnoreCase","network_1","isLinux","parentCandidate","originalFSPath","isEqualAuthority","a1","a2","uriPath","hasTrailingPathSeparator","fsp","p","fsPath","relativePath","fromPath","toPath","getComparisonKey","basenameOrAuthority","second","p1","p2","console","with","joinPath","pathFragment","joinedPath","normalizePath","normalizedPath","isAbsolutePath","removeTrailingPathSeparator","addTrailingPathSeparator","isRootSep","resolvePath","newURI","distinctParents","resourceAccessor","candidateResource","otherItem","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","property","mime","ResourceGlobMatcher","globalExpression","rootExpressions","expressionsByRoot","forPaths","glob_1","rootExpression","findSubstr","toLocalResource","OutputLinkComputer","ctx","createData","computePatterns","workspaceFolders","sort","resourceStrA","resourceStrB","resourceStr","workspaceFolder","createPatterns","models","getMirrorModels","arrays_1","find","model","getModel","links","lines","getValue","folderUri","folderPatterns","resourceCreator","toResource","folderRelativePath","resources","detectLinks","workspaceFolderPath","workspaceFolderVariants","workspaceFolderVariant","validPathCharacterPattern","pathPattern","strictPathPattern","line","lineIndex","resourceString","lineNumber","columnNumber","fullMatch","linkRange","startColumn","startLineNumber","endColumn","endLineNumber","link","range_1","Range","areIntersectingOrTouching","range","url","call"],"mappings":"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","file":"outputLinkComputer.js","sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\n\nexport function isThenable<T>(obj: any): obj is Promise<T> {\n\treturn obj && typeof (<Promise<any>>obj).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tsource.token.onCancellationRequested(() => {\n\t\t\treject(errors.canceled());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T> {\n\treturn Promise.race([promise, new Promise<T>(resolve => token.onCancellationRequested(() => resolve(defaultValue)))]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(c => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(c);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((c, e) => {\n\t\t\t\tthis.queuedPromise!.then(c, e);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((c, e) => {\n\t\t\tthis.activePromise!.then((result: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tc(result);\n\t\t\t}, (err: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\te(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<any> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask());\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate timeout: any;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number) {\n\t\tthis.timeout = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay: number = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((c, e) => {\n\t\t\t\tthis.doResolve = c;\n\t\t\t\tthis.doReject = e;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tthis.timeout = setTimeout(() => {\n\t\t\tthis.timeout = null;\n\t\t\tif (this.doResolve) {\n\t\t\t\tthis.doResolve(null);\n\t\t\t}\n\t\t}, delay);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.timeout !== null;\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tif (this.doReject) {\n\t\t\t\tthis.doReject(errors.canceled());\n\t\t\t}\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tif (this.timeout !== null) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancelTimeout();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as any as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(resolve, millis);\n\t\ttoken.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\treject(errors.canceled());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\nexport function ignoreErrors<T>(promise: Promise<T>): Promise<T | undefined> {\n\treturn promise.then(undefined, _ => undefined);\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value?: T | Promise<T>) => void;\n\te: (error?: any) => void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> {\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate maxDegreeOfParalellism: number;\n\tprivate outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onFinished: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onFinished = new Emitter<void>();\n\t}\n\n\tget onFinished(): Event<void> {\n\t\treturn this._onFinished.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t\t// return this.runningPromises + this.outstandingPromises.length;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onFinished.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onFinished.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tqueueFor(resource: URI): Queue<void> {\n\t\tconst key = resource.toString();\n\t\tif (!this.queues.has(key)) {\n\t\t\tconst queue = new Queue<void>();\n\t\t\tqueue.onFinished(() => {\n\t\t\t\tqueue.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t});\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn this.queues.get(key)!;\n\t}\n\n\tdispose(): void {\n\t\tthis.queues.forEach(queue => queue.dispose());\n\t\tthis.queues.clear();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler {\n\n\tprotected runner: ((...args: any[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, timeout: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = timeout;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tif (this.runner) {\n\t\t\tthis.runner();\n\t\t}\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tif (this.runner) {\n\t\t\tthis.runner(units);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\tconst dummyIdle: IdleDeadline = Object.freeze({\n\t\t\tdidTimeout: true,\n\t\t\ttimeRemaining() { return 15; }\n\t\t});\n\t\trunWhenIdle = (runner) => {\n\t\t\tconst handle = setTimeout(() => runner(dummyIdle));\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: any;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tgetValue(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows, isMacintosh, setImmediate, IProcessEnvironment } from 'vs/base/common/platform';\n\ninterface IProcess {\n\tplatform: string;\n\tenv: IProcessEnvironment;\n\n\tcwd(): string;\n\tnextTick(callback: (...args: any[]) => void): void;\n}\n\ndeclare const process: IProcess;\nconst safeProcess: IProcess = (typeof process === 'undefined') ? {\n\tcwd(): string { return '/'; },\n\tenv: Object.create(null),\n\tget platform(): string { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n\tnextTick(callback: (...args: any[]) => void): void { return setImmediate(callback); }\n} : process;\n\nexport const cwd = safeProcess.cwd;\nexport const env = safeProcess.env;\nexport const platform = safeProcess.platform;\nexport const nextTick = safeProcess.nextTick;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/tree/43dd49c9782848c25e5b03448c8a0f923f13c158\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from 'vs/base/common/process';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: any) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tlet msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\n\t\tthis.code = 'ERR_INVALID_ARG_TYPE';\n\t}\n}\n\nfunction validateString(value: string, name: string) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nfunction isPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code: number) {\n\treturn code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\n\t\tcode >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path: string, allowAboveRoot: boolean, separator: string, isPathSeparator: (code?: number) => boolean) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (lastSlash !== i - 1 && dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length === 2 || res.length === 1) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tif (res.length > 0) {\n\t\t\t\t\t\tres += `${separator}..`;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = '..';\n\t\t\t\t\t}\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += separator + path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t((pathObject.name || '') + (pathObject.ext || ''));\n\tif (!dir) {\n\t\treturn base;\n\t}\n\tif (dir === pathObject.root) {\n\t\treturn dir + base;\n\t}\n\treturn dir + sep + base;\n}\n\nexport interface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\nexport interface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, ext?: string): string;\n\textname(path: string): string;\n\tformat(pathObject: ParsedPath): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t} else if (!resolvedDevice) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = (process.env as any)['=' + resolvedDevice] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\tpath.slice(0, 3).toLowerCase() !==\n\t\t\t\t\tresolvedDevice.toLowerCase() + '\\\\') {\n\t\t\t\t\tpath = resolvedDevice + '\\\\';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len > 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// Possible UNC root\n\n\t\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\t\tisAbsolute = true;\n\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\t\tlet j = 2;\n\t\t\t\t\t\tlet last = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t\t// We matched a UNC root only\n\n\t\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\n\t\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n\t\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trootEnd = 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t\t// Possible device root\n\n\t\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\t\t\trootEnd = 2;\n\t\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t\t\t\t// indicator\n\t\t\t\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator\n\t\t\t\trootEnd = 1;\n\t\t\t\tisAbsolute = true;\n\t\t\t}\n\n\t\t\tif (device.length > 0 &&\n\t\t\t\tresolvedDevice.length > 0 &&\n\t\t\t\tdevice.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (resolvedDevice.length === 0 && device.length > 0) {\n\t\t\t\tresolvedDevice = device;\n\t\t\t}\n\t\t\tif (!resolvedAbsolute) {\n\t\t\t\tresolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t}\n\n\t\t\tif (resolvedDevice.length > 0 && resolvedAbsolute) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\n\t\t\t'.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t\t// path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t\t// is nothing left to process\n\n\t\t\t\t\t\t\t\treturn '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\n\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\t\trootEnd = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t\t\t// indicator\n\t\t\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid unnecessary\n\t\t\t// work\n\t\t\treturn '\\\\';\n\t\t}\n\n\t\tlet tail;\n\t\tif (rootEnd < len) {\n\t\t\ttail = normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\',\n\t\t\t\tisPathSeparator);\n\t\t} else {\n\t\t\ttail = '';\n\t\t}\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (device === undefined) {\n\t\t\tif (isAbsolute) {\n\t\t\t\tif (tail.length > 0) {\n\t\t\t\t\treturn '\\\\' + tail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn '\\\\';\n\t\t\t\t}\n\t\t\t} else if (tail.length > 0) {\n\t\t\t\treturn tail;\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t} else if (isAbsolute) {\n\t\t\tif (tail.length > 0) {\n\t\t\t\treturn device + '\\\\' + tail;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn device + '\\\\';\n\t\t\t}\n\t\t} else if (tail.length > 0) {\n\t\t\treturn device + tail;\n\t\t} else {\n\t\t\treturn device;\n\t\t}\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\tif (isPathSeparator(code)) {\n\t\t\treturn true;\n\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t// Possible device root\n\n\t\t\tif (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart: string | undefined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += '\\\\' + arg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for an UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at an UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as an UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1) {\n\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t\t++slashCount;\n\t\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\tfor (; slashCount < joined.length; ++slashCount) {\n\t\t\t\tif (!isPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = '\\\\' + joined.slice(slashCount);\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\tfor (; fromStart < from.length; ++fromStart) {\n\t\t\tif (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\tfor (; fromEnd - 1 > fromStart; --fromEnd) {\n\t\t\tif (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst fromLen = (fromEnd - fromStart);\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\tfor (; toStart < to.length; ++toStart) {\n\t\t\tif (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\tfor (; toEnd - 1 > toStart; --toEnd) {\n\t\t\tif (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst toLen = (toEnd - toStart);\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i <= length; ++i) {\n\t\t\tif (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fromLen > length) {\n\t\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tconst toCode = to.charCodeAt(toStart + i);\n\t\t\tif (fromCode !== toCode) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length && lastCommonSep === -1) {\n\t\t\treturn toOrig;\n\t\t}\n\n\t\tlet out = '';\n\t\tif (lastCommonSep === -1) {\n\t\t\tlastCommonSep = 0;\n\t\t}\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tif (out.length === 0) {\n\t\t\t\t\tout += '..';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout += '\\\\..';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn out + toOrig.slice(toStart + lastCommonSep, toEnd);\n\t\t}\n\t\telse {\n\t\t\ttoStart += lastCommonSep;\n\t\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t++toStart;\n\t\t\t}\n\t\t\treturn toOrig.slice(toStart, toEnd);\n\t\t}\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string') {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length >= 3) {\n\t\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\t\treturn '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\t\t\treturn '\\\\\\\\?\\\\' + resolvedPath;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\trootEnd = offset = 1;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\trootEnd = offset = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\trootEnd = offset = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn path;\n\t\t}\n\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tend = rootEnd;\n\t\t\t}\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2) {\n\t\t\tconst drive = path.charCodeAt(0);\n\t\t\tif (isWindowsDeviceRoot(drive)) {\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\tstart = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext.length === path.length && ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t}\n\t\t\telse if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t} else {\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (end === -1) {\n\t\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t\t// path component\n\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\tend = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end === -1) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat(pathObject): string {\n\t\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t\t}\n\n\t\treturn _format('\\\\', pathObject);\n\t},\n\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\trootEnd = 1;\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\trootEnd = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\tif (len === 3) {\n\t\t\t\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t\t\t\t// unnecessary work\n\t\t\t\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t\t// unnecessary work\n\t\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\tret.root = ret.dir = path;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\tif (end !== -1) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t}\n\t\t} else {\n\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\tret.base = path.slice(startPart, end);\n\t\t\tret.ext = path.slice(startDot, end);\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t}\n\t\telse {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = process.cwd();\n\t\t\t}\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = path + '/' + resolvedPath;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\tif (resolvedPath.length > 0) {\n\t\t\t\treturn '/' + resolvedPath;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t} else if (resolvedPath.length > 0) {\n\t\t\treturn resolvedPath;\n\t\t} else {\n\t\t\treturn '.';\n\t\t}\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0 && !isAbsolute) {\n\t\t\tpath = '.';\n\t\t}\n\t\tif (path.length > 0 && trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\tif (isAbsolute) {\n\t\t\treturn '/' + path;\n\t\t}\n\t\treturn path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet joined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = arguments[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += '/' + arg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\t\treturn posix.normalize(joined);\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 1;\n\t\tfor (; fromStart < from.length; ++fromStart) {\n\t\t\tif (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = (fromEnd - fromStart);\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 1;\n\t\tfor (; toStart < to.length; ++toStart) {\n\t\t\tif (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst toEnd = to.length;\n\t\tconst toLen = (toEnd - toStart);\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i <= length; ++i) {\n\t\t\tif (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t\t}\n\t\t\t\t} else if (fromLen > length) {\n\t\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t\t// For example: from='/foo'; to='/'\n\t\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tconst toCode = to.charCodeAt(toStart + i);\n\t\t\tif (fromCode !== toCode) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (out.length === 0) {\n\t\t\t\t\tout += '..';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout += '/..';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn out + to.slice(toStart + lastCommonSep);\n\t\t}\n\t\telse {\n\t\t\ttoStart += lastCommonSep;\n\t\t\tif (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) {\n\t\t\t\t++toStart;\n\t\t\t}\n\t\t\treturn to.slice(toStart);\n\t\t}\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext.length === path.length && ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t}\n\t\t\telse if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t} else {\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (end === -1) {\n\t\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t\t// path component\n\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\tend = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end === -1) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat(pathObject): string {\n\t\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t\t}\n\n\t\treturn _format('/', pathObject);\n\t},\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\tif (end !== -1) {\n\t\t\t\tif (startPart === 0 && isAbsolute) {\n\t\t\t\t\tret.base = ret.name = path.slice(1, end);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (startPart === 0 && isAbsolute) {\n\t\t\t\tret.name = path.slice(1, startDot);\n\t\t\t\tret.base = path.slice(1, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t}\n\t\t\tret.ext = path.slice(startDot, end);\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t}\n\t\telse if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\nexport const isAbsolute = (process.platform === 'win32' ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (process.platform === 'win32' ? win32.join : posix.join);\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\nexport const format = (process.platform === 'win32' ? win32.format : posix.format);\nexport const parse = (process.platform === 'win32' ? win32.parse : posix.parse);\nexport const toNamespacedPath = (process.platform === 'win32' ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\nexport const delimiter = (process.platform === 'win32' ? win32.delimiter : posix.delimiter);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { startsWithIgnoreCase, equalsIgnoreCase, endsWith, rtrim } from 'vs/base/common/strings';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { sep, posix, isAbsolute, join, normalize } from 'vs/base/common/path';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(1);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(pos + 1);\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\nexport function isEqualOrParent(path: string, candidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (path === candidate) {\n\t\treturn true;\n\t}\n\n\tif (!path || !candidate) {\n\t\treturn false;\n\t}\n\n\tif (candidate.length > path.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(path, candidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (candidate.length === path.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = candidate.length;\n\t\tif (candidate.charAt(candidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn path.charAt(sepOffset) === separator;\n\t}\n\n\tif (candidate.charAt(candidate.length - 1) !== separator) {\n\t\tcandidate += separator;\n\t}\n\n\treturn path.indexOf(candidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && endsWith(candidate, ':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (endsWith(candidate, ':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isWindowsDriveLetter(pathNormalized.charCodeAt(0))\n\t\t\t&& pathNormalized.charCodeAt(1) === CharCode.Colon\n\t\t\t&& (path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { Iterator, IteratorResult, FIN } from './iterator';\n\n\nexport function values<V = any>(set: Set<V>): V[];\nexport function values<K = any, V = any>(map: Map<K, V>): V[];\nexport function values<V>(forEachable: { forEach(callback: (value: V, ...more: any[]) => any): void }): V[] {\n\tconst result: V[] = [];\n\tforEachable.forEach(value => result.push(value));\n\treturn result;\n}\n\nexport function keys<K, V>(map: Map<K, V>): K[] {\n\tconst result: K[] = [];\n\tmap.forEach((_value, key) => result.push(key));\n\n\treturn result;\n}\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\nexport function mapToSerializable(map: Map<string, string>): [string, string][] {\n\tconst serializable: [string, string][] = [];\n\n\tmap.forEach((value, key) => {\n\t\tserializable.push([key, value]);\n\t});\n\n\treturn serializable;\n}\n\nexport function serializableToMap(serializable: [string, string][]): Map<string, string> {\n\tconst items = new Map<string, string>();\n\n\tfor (const [key, value] of serializable) {\n\t\titems.set(key, value);\n\t}\n\n\treturn items;\n}\n\nexport interface IKeyIterator {\n\treset(key: string): this;\n\tnext(): this;\n\n\thasNext(): boolean;\n\tcmp(a: string): number;\n\tvalue(): string;\n}\n\nexport class StringIterator implements IKeyIterator {\n\n\tprivate _value: string = '';\n\tprivate _pos: number = 0;\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._pos = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tthis._pos += 1;\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._pos < this._value.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tconst aCode = a.charCodeAt(0);\n\t\tconst thisCode = this._value.charCodeAt(this._pos);\n\t\treturn aCode - thisCode;\n\t}\n\n\tvalue(): string {\n\t\treturn this._value[this._pos];\n\t}\n}\n\nexport class PathIterator implements IKeyIterator {\n\n\tprivate _value!: string;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(private _splitOnBackslash: boolean = true) { }\n\n\treset(key: string): this {\n\t\tthis._value = key.replace(/\\\\$|\\/$/, '');\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._value.length;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._value.length; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\n\t\tlet aPos = 0;\n\t\tconst aLen = a.length;\n\t\tlet thisPos = this._from;\n\n\t\twhile (aPos < aLen && thisPos < this._to) {\n\t\t\tconst cmp = a.charCodeAt(aPos) - this._value.charCodeAt(thisPos);\n\t\t\tif (cmp !== 0) {\n\t\t\t\treturn cmp;\n\t\t\t}\n\t\t\taPos += 1;\n\t\t\tthisPos += 1;\n\t\t}\n\n\t\tif (aLen === this._to - this._from) {\n\t\t\treturn 0;\n\t\t} else if (aPos < aLen) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nclass TernarySearchTreeNode<E> {\n\tsegment!: string;\n\tvalue: E | undefined;\n\tkey!: string;\n\tleft: TernarySearchTreeNode<E> | undefined;\n\tmid: TernarySearchTreeNode<E> | undefined;\n\tright: TernarySearchTreeNode<E> | undefined;\n\n\tisEmpty(): boolean {\n\t\treturn !this.left && !this.mid && !this.right && !this.value;\n\t}\n}\n\nexport class TernarySearchTree<E> {\n\n\tstatic forPaths<E>(): TernarySearchTree<E> {\n\t\treturn new TernarySearchTree<E>(new PathIterator());\n\t}\n\n\tstatic forStrings<E>(): TernarySearchTree<E> {\n\t\treturn new TernarySearchTree<E>(new StringIterator());\n\t}\n\n\tprivate _iter: IKeyIterator;\n\tprivate _root: TernarySearchTreeNode<E> | undefined;\n\n\tconstructor(segments: IKeyIterator) {\n\t\tthis._iter = segments;\n\t}\n\n\tclear(): void {\n\t\tthis._root = undefined;\n\t}\n\n\tset(key: string, element: E): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node: TernarySearchTreeNode<E>;\n\n\t\tif (!this._root) {\n\t\t\tthis._root = new TernarySearchTreeNode<E>();\n\t\t\tthis._root.segment = iter.value();\n\t\t}\n\n\t\tnode = this._root;\n\t\twhile (true) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tif (!node.left) {\n\t\t\t\t\tnode.left = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.left.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.left;\n\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tif (!node.right) {\n\t\t\t\t\tnode.right = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.right.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.right;\n\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tnode.mid = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.mid.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst oldElement = node.value;\n\t\tnode.value = element;\n\t\tnode.key = key;\n\t\treturn oldElement;\n\t}\n\n\tget(key: string): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node ? node.value : undefined;\n\t}\n\n\tdelete(key: string): void {\n\n\t\tconst iter = this._iter.reset(key);\n\t\tconst stack: [-1 | 0 | 1, TernarySearchTreeNode<E>][] = [];\n\t\tlet node = this._root;\n\n\t\t// find and unset node\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tstack.push([1, node]);\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tstack.push([-1, node]);\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tstack.push([0, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// remove element\n\t\t\t\tnode.value = undefined;\n\n\t\t\t\t// clean up empty nodes\n\t\t\t\twhile (stack.length > 0 && node.isEmpty()) {\n\t\t\t\t\tlet [dir, parent] = stack.pop()!;\n\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\tcase 1: parent.left = undefined; break;\n\t\t\t\t\t\tcase 0: parent.mid = undefined; break;\n\t\t\t\t\t\tcase -1: parent.right = undefined; break;\n\t\t\t\t\t}\n\t\t\t\t\tnode = parent;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfindSubstr(key: string): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\tlet candidate: E | undefined = undefined;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tcandidate = node.value || candidate;\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node && node.value || candidate;\n\t}\n\n\tfindSuperstr(key: string): Iterator<E> | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// collect\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\treturn this._nodeIterator(node.mid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _nodeIterator(node: TernarySearchTreeNode<E>): Iterator<E> {\n\t\tlet res: { done: false; value: E; };\n\t\tlet idx: number;\n\t\tlet data: E[];\n\t\tconst next = (): IteratorResult<E> => {\n\t\t\tif (!data) {\n\t\t\t\t// lazy till first invocation\n\t\t\t\tdata = [];\n\t\t\t\tidx = 0;\n\t\t\t\tthis._forEach(node, value => data.push(value));\n\t\t\t}\n\t\t\tif (idx >= data.length) {\n\t\t\t\treturn FIN;\n\t\t\t}\n\n\t\t\tif (!res) {\n\t\t\t\tres = { done: false, value: data[idx++] };\n\t\t\t} else {\n\t\t\t\tres.value = data[idx++];\n\t\t\t}\n\t\t\treturn res;\n\t\t};\n\t\treturn { next };\n\t}\n\n\tforEach(callback: (value: E, index: string) => any) {\n\t\tthis._forEach(this._root, callback);\n\t}\n\n\tprivate _forEach(node: TernarySearchTreeNode<E> | undefined, callback: (value: E, index: string) => any) {\n\t\tif (node) {\n\t\t\t// left\n\t\t\tthis._forEach(node.left, callback);\n\n\t\t\t// node\n\t\t\tif (node.value) {\n\t\t\t\t// callback(node.value, this._iter.join(parts));\n\t\t\t\tcallback(node.value, node.key);\n\t\t\t}\n\t\t\t// mid\n\t\t\tthis._forEach(node.mid, callback);\n\n\t\t\t// right\n\t\t\tthis._forEach(node.right, callback);\n\t\t}\n\t}\n}\n\nexport class ResourceMap<T> {\n\n\tprotected readonly map: Map<string, T>;\n\tprotected readonly ignoreCase?: boolean;\n\n\tconstructor() {\n\t\tthis.map = new Map<string, T>();\n\t\tthis.ignoreCase = false; // in the future this should be an uri-comparator\n\t}\n\n\tset(resource: URI, value: T): void {\n\t\tthis.map.set(this.toKey(resource), value);\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource));\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI) => void): void {\n\t\tthis.map.forEach((value, index) => clb(value, URI.parse(index)));\n\t}\n\n\tvalues(): T[] {\n\t\treturn values(this.map);\n\t}\n\n\tprivate toKey(resource: URI): string {\n\t\tlet key = resource.toString();\n\t\tif (this.ignoreCase) {\n\t\t\tkey = key.toLowerCase();\n\t\t}\n\n\t\treturn key;\n\t}\n\n\tkeys(): URI[] {\n\t\treturn keys(this.map).map(k => URI.parse(k));\n\t}\n\n\tclone(): ResourceMap<T> {\n\t\tconst resourceMap = new ResourceMap<T>();\n\n\t\tthis.map.forEach((value, key) => resourceMap.map.set(key, value));\n\n\t\treturn resourceMap;\n\t}\n}\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> {\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): void {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tvalues(): V[] {\n\t\tconst result: V[] = [];\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tresult.push(current.value);\n\t\t\tcurrent = current.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\tkeys(): K[] {\n\t\tconst result: K[] = [];\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tresult.push(current.key);\n\t\t\tcurrent = current.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* VS Code / Monaco editor runs on es5 which has no Symbol.iterator\n\tkeys(): IterableIterator<K> {\n\t\tconst current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext():IteratorResult<K> {\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext():IteratorResult<V> {\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\t*/\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nexport class LRUCache<K, V> extends LinkedMap<K, V> {\n\n\tprivate _limit: number;\n\tprivate _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn super.get(key, Touch.AsNew);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\tset(key: K, value: V): void {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\tthis.checkTrim();\n\t}\n\n\tprivate checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trimOld(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport * as strings from 'vs/base/common/strings';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { LRUCache } from 'vs/base/common/map';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isThenable } from 'vs/base/common/async';\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport interface IRelativePattern {\n\tbase: string;\n\tpattern: string;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\nexport interface SiblingClause {\n\twhen: string;\n}\n\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(s => s === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Globstar is special\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (!previousSegmentWasGlobStar) {\n\t\t\t\t\tregEx += starsToRegExp(2);\n\t\t\t\t\tpreviousSegmentWasGlobStar = true;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// States\n\t\t\tlet inBraces = false;\n\t\t\tlet braceVal = '';\n\n\t\t\tlet inBrackets = false;\n\t\t\tlet bracketVal = '';\n\n\t\t\tfor (const char of segment) {\n\t\t\t\t// Support brace expansion\n\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\tbraceVal += char;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Support brackets\n\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t// range operator\n\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\tres = char;\n\t\t\t\t\t}\n\n\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\tres = '^';\n\t\t\t\t\t}\n\n\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t}\n\n\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = strings.escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\n\t\t\t\t\tbracketVal += res;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (char) {\n\t\t\t\t\tcase '{':\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '}':\n\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n\n\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tregEx += strings.escapeRegExpCharacters(char);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n\t\t\t// a folder called \"something\" to match as well.\n\t\t\t// However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n\t\t\t// is to match 0-N segments.\n\t\t\tif (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n\t\t\t\tregEx += PATH_REGEX;\n\t\t\t}\n\n\t\t\t// reset state\n\t\t\tpreviousSegmentWasGlobStar = false;\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trival glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t   \t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t   \t\t\t// **/something\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; \t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t   \t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t   \t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The ParsedExpression returns a Promise iff hasSibling returns a Promise.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\nexport interface IGlobOptions {\n\t/**\n\t * Simplify patterns for use as exclusion filters during tree traversal to skip entire subtrees. Cannot be used outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\ninterface ParsedExpressionPattern {\n\t(path: string, basename: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle IRelativePattern\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivias\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\n\t\tconst base = pattern.substr(4); // '**/*'.length === 4\n\t\tparsedPattern = function (path, basename) {\n\t\t\treturn typeof path === 'string' && strings.endsWith(path, base) ? pattern : null;\n\t\t};\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\treturn function (path, basename) {\n\t\tif (!extpath.isEqualOrParent(path, arg2.base)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn parsedPattern(paths.relative(arg2.base, path), basename);\n\t};\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, originalPattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\tconst parsedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (basename) {\n\t\t\treturn basename === base ? originalPattern : null;\n\t\t}\n\t\treturn path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;\n\t};\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [originalPattern];\n\tparsedPattern.allBasenames = basenames;\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\tif (n === 1) {\n\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t}\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif ((<ParsedStringPattern>parsedPatterns[i])(path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(path: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\n\tconst nativePathEnd = paths.sep + nativePath;\n\tconst parsedPattern: ParsedStringPattern = matchPathEnds ? function (path, basename) {\n\t\treturn typeof path === 'string' && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;\n\t} : function (path, basename) {\n\t\treturn typeof path === 'string' && path === nativePath ? pattern : null;\n\t};\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string, basename: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(<IExpression>arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[]; } = function (path: string, basename: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([]))\n\t\t\t\t.then(list => list ? listToMap(list) : {});\n\t\t}\n\t\treturn siblings.then(map => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern;\n\n\treturn rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (n === 1) {\n\t\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename: string) {\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\t// Pattern matches path\n\t\t\t\tconst result = (<ParsedStringPattern>parsedPatterns[i])(path, basename);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, basename: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!basename) {\n\t\t\t\t\tbasename = paths.basename(path);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = basename.substr(0, basename.length - paths.extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst result = parsedPattern(path, basename, name, hasSibling);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = (<SiblingClause>value).when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename: string, name: string, hasSibling: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', name);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(m => m ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\t\t\tresult.requiresSiblings = true;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is Anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, <string[]>[]);\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, <string[]>[]);\n\t}\n\tconst aggregate: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbasename = path.substr(i);\n\t\t}\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\treturn aggregatedPatterns;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport * as platform from 'vs/base/common/platform';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const userData = 'vscode-userdata';\n}\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined; } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined; } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined; } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\treturn this._delegate(uri);\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\t// const port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&tkn=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\t// NOTE@coder: Changed this to work against the current path.\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: window.location.host,\n\t\t\tpath: `${window.location.pathname.replace(/\\/+$/, '')}/vscode-remote-resource`,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { URI } from 'vs/base/common/uri';\nimport { equalsIgnoreCase } from 'vs/base/common/strings';\nimport { Schemas } from 'vs/base/common/network';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { ParsedExpression, IExpression, parse } from 'vs/base/common/glob';\nimport { TernarySearchTree } from 'vs/base/common/map';\n\nexport function getComparisonKey(resource: URI): string {\n\treturn hasToIgnoreCase(resource) ? resource.toString().toLowerCase() : resource.toString();\n}\n\nexport function hasToIgnoreCase(resource: URI | undefined): boolean {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn resource && resource.scheme === Schemas.file ? !isLinux : true;\n}\n\nexport function basenameOrAuthority(resource: URI): string {\n\treturn basename(resource) || resource.authority;\n}\n\n/**\n * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n * @param base A uri which is \"longer\"\n * @param parentCandidate A uri which is \"shorter\" then `base`\n */\nexport function isEqualOrParent(base: URI, parentCandidate: URI, ignoreCase = hasToIgnoreCase(base)): boolean {\n\tif (base.scheme === parentCandidate.scheme) {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), ignoreCase);\n\t\t}\n\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, ignoreCase, '/');\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Tests wheter the two authorities are the same\n */\nexport function isEqualAuthority(a1: string, a2: string) {\n\treturn a1 === a2 || equalsIgnoreCase(a1, a2);\n}\n\nexport function isEqual(first: URI | undefined, second: URI | undefined, ignoreCase = hasToIgnoreCase(first)): boolean {\n\tif (first === second) {\n\t\treturn true;\n\t}\n\n\tif (!first || !second) {\n\t\treturn false;\n\t}\n\n\tif (first.scheme !== second.scheme || !isEqualAuthority(first.authority, second.authority)) {\n\t\treturn false;\n\t}\n\n\tconst p1 = first.path || '/', p2 = second.path || '/';\n\treturn p1 === p2 || ignoreCase && equalsIgnoreCase(p1 || '/', p2 || '/');\n}\n\nexport function basename(resource: URI): string {\n\treturn paths.posix.basename(resource.path);\n}\n\nexport function extname(resource: URI): string {\n\treturn paths.posix.extname(resource.path);\n}\n\n/**\n * Return a URI representing the directory of a URI path.\n *\n * @param resource The input URI.\n * @returns The URI representing the directory of the input URI.\n */\nexport function dirname(resource: URI): URI {\n\tif (resource.path.length === 0) {\n\t\treturn resource;\n\t}\n\tif (resource.scheme === Schemas.file) {\n\t\treturn URI.file(paths.dirname(originalFSPath(resource)));\n\t}\n\tlet dirname = paths.posix.dirname(resource.path);\n\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t}\n\treturn resource.with({\n\t\tpath: dirname\n\t});\n}\n\n/**\n * Join a URI path with path fragments and normalizes the resulting path.\n *\n * @param resource The input URI.\n * @param pathFragment The path fragment to add to the URI path.\n * @returns The resulting URI.\n */\nexport function joinPath(resource: URI, ...pathFragment: string[]): URI {\n\tlet joinedPath: string;\n\tif (resource.scheme === Schemas.file) {\n\t\tjoinedPath = URI.file(paths.join(originalFSPath(resource), ...pathFragment)).path;\n\t} else {\n\t\tjoinedPath = paths.posix.join(resource.path || '/', ...pathFragment);\n\t}\n\treturn resource.with({\n\t\tpath: joinedPath\n\t});\n}\n\n/**\n * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n *\n * @param resource The URI to normalize the path.\n * @returns The URI with the normalized path.\n */\nexport function normalizePath(resource: URI): URI {\n\tif (!resource.path.length) {\n\t\treturn resource;\n\t}\n\tlet normalizedPath: string;\n\tif (resource.scheme === Schemas.file) {\n\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t} else {\n\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t}\n\treturn resource.with({\n\t\tpath: normalizedPath\n\t});\n}\n\n/**\n * Returns the fsPath of an URI where the drive letter is not normalized.\n * See #56403.\n */\nexport function originalFSPath(uri: URI): string {\n\tlet value: string;\n\tconst uriPath = uri.path;\n\tif (uri.authority && uriPath.length > 1 && uri.scheme === Schemas.file) {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uriPath}`;\n\t} else if (\n\t\tisWindows\n\t\t&& uriPath.charCodeAt(0) === CharCode.Slash\n\t\t&& extpath.isWindowsDriveLetter(uriPath.charCodeAt(1))\n\t\t&& uriPath.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tvalue = uriPath.substr(1);\n\t} else {\n\t\t// other path\n\t\tvalue = uriPath;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Returns true if the URI path is absolute.\n */\nexport function isAbsolutePath(resource: URI): boolean {\n\treturn !!resource.path && resource.path[0] === '/';\n}\n\n/**\n * Returns true if the URI path has a trailing path separator\n */\nexport function hasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\tif (resource.scheme === Schemas.file) {\n\t\tconst fsp = originalFSPath(resource);\n\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t} else {\n\t\tconst p = resource.path;\n\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t}\n}\n\n/**\n * Removes a trailing path separator, if there's one.\n * Important: Doesn't remove the first slash, it would make the URI invalid\n */\nexport function removeTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t}\n\treturn resource;\n}\n\n/**\n * Adds a trailing path separator to the URI if there isn't one already.\n * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n */\nexport function addTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\tlet isRootSep: boolean = false;\n\tif (resource.scheme === Schemas.file) {\n\t\tconst fsp = originalFSPath(resource);\n\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t} else {\n\t\tsep = '/';\n\t\tconst p = resource.path;\n\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t}\n\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\treturn resource.with({ path: resource.path + '/' });\n\t}\n\treturn resource;\n}\n\n/**\n * Returns a relative path between two URIs. If the URIs don't have the same schema or authority, `undefined` is returned.\n * The returned relative path always uses forward slashes.\n */\nexport function relativePath(from: URI, to: URI, ignoreCase = hasToIgnoreCase(from)): string | undefined {\n\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\treturn undefined;\n\t}\n\tif (from.scheme === Schemas.file) {\n\t\tconst relativePath = paths.relative(from.path, to.path);\n\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t}\n\tlet fromPath = from.path || '/', toPath = to.path || '/';\n\tif (ignoreCase) {\n\t\t// make casing of fromPath match toPath\n\t\tlet i = 0;\n\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t}\n\treturn paths.posix.relative(fromPath, toPath);\n}\n\n/**\n * Resolves an absolute or relative path against a base URI.\n * The path can be relative or absolute posix or a Windows path\n */\nexport function resolvePath(base: URI, path: string): URI {\n\tif (base.scheme === Schemas.file) {\n\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\treturn base.with({\n\t\t\tauthority: newURI.authority,\n\t\t\tpath: newURI.path\n\t\t});\n\t}\n\tif (path.indexOf('/') === -1) { // no slashes? it's likely a Windows path\n\t\tpath = extpath.toSlashes(path);\n\t\tif (/^[a-zA-Z]:(\\/|$)/.test(path)) { // starts with a drive letter\n\t\t\tpath = '/' + path;\n\t\t}\n\t}\n\treturn base.with({\n\t\tpath: paths.posix.resolve(base.path, path)\n\t});\n}\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport class ResourceGlobMatcher {\n\n\tprivate readonly globalExpression: ParsedExpression;\n\tprivate readonly expressionsByRoot: TernarySearchTree<{ root: URI, expression: ParsedExpression }> = TernarySearchTree.forPaths<{ root: URI, expression: ParsedExpression }>();\n\n\tconstructor(\n\t\tglobalExpression: IExpression,\n\t\trootExpressions: { root: URI, expression: IExpression }[]\n\t) {\n\t\tthis.globalExpression = parse(globalExpression);\n\t\tfor (const expression of rootExpressions) {\n\t\t\tthis.expressionsByRoot.set(expression.root.toString(), { root: expression.root, expression: parse(expression.expression) });\n\t\t}\n\t}\n\n\tmatches(resource: URI): boolean {\n\t\tconst rootExpression = this.expressionsByRoot.findSubstr(resource.toString());\n\t\tif (rootExpression) {\n\t\t\tconst path = relativePath(rootExpression.root, resource);\n\t\t\tif (path && !!rootExpression.expression(path)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn !!this.globalExpression(resource.path);\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: Schemas.vscodeRemote, authority, path });\n\t}\n\n\treturn resource.with({ scheme: Schemas.file });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMirrorModel, IWorkerContext } from 'vs/editor/common/services/editorSimpleWorker';\nimport { ILink } from 'vs/editor/common/modes';\nimport { URI } from 'vs/base/common/uri';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as resources from 'vs/base/common/resources';\nimport * as strings from 'vs/base/common/strings';\nimport { Range } from 'vs/editor/common/core/range';\nimport { isWindows } from 'vs/base/common/platform';\nimport { Schemas } from 'vs/base/common/network';\nimport { find } from 'vs/base/common/arrays';\n\nexport interface ICreateData {\n\tworkspaceFolders: string[];\n}\n\nexport interface IResourceCreator {\n\ttoResource: (folderRelativePath: string) => URI | null;\n}\n\nexport class OutputLinkComputer {\n\tprivate patterns = new Map<URI /* folder uri */, RegExp[]>();\n\n\tconstructor(private ctx: IWorkerContext, createData: ICreateData) {\n\t\tthis.computePatterns(createData);\n\t}\n\n\tprivate computePatterns(createData: ICreateData): void {\n\n\t\t// Produce patterns for each workspace root we are configured with\n\t\t// This means that we will be able to detect links for paths that\n\t\t// contain any of the workspace roots as segments.\n\t\tconst workspaceFolders = createData.workspaceFolders\n\t\t\t.sort((resourceStrA, resourceStrB) => resourceStrB.length - resourceStrA.length) // longest paths first (for https://github.com/microsoft/vscode/issues/88121)\n\t\t\t.map(resourceStr => URI.parse(resourceStr));\n\n\t\tfor (const workspaceFolder of workspaceFolders) {\n\t\t\tconst patterns = OutputLinkComputer.createPatterns(workspaceFolder);\n\t\t\tthis.patterns.set(workspaceFolder, patterns);\n\t\t}\n\t}\n\n\tprivate getModel(uri: string): IMirrorModel | undefined {\n\t\tconst models = this.ctx.getMirrorModels();\n\n\t\treturn find(models, model => model.uri.toString() === uri);\n\t}\n\n\tcomputeLinks(uri: string): ILink[] {\n\t\tconst model = this.getModel(uri);\n\t\tif (!model) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst links: ILink[] = [];\n\t\tconst lines = model.getValue().split(/\\r\\n|\\r|\\n/);\n\n\t\t// For each workspace root patterns\n\t\tfor (const [folderUri, folderPatterns] of this.patterns) {\n\t\t\tconst resourceCreator: IResourceCreator = {\n\t\t\t\ttoResource: (folderRelativePath: string): URI | null => {\n\t\t\t\t\tif (typeof folderRelativePath === 'string') {\n\t\t\t\t\t\treturn resources.joinPath(folderUri, folderRelativePath);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\t\tlinks.push(...OutputLinkComputer.detectLinks(lines[i], i + 1, folderPatterns, resourceCreator));\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n\n\tstatic createPatterns(workspaceFolder: URI): RegExp[] {\n\t\tconst patterns: RegExp[] = [];\n\n\t\tconst workspaceFolderPath = workspaceFolder.scheme === Schemas.file ? workspaceFolder.fsPath : workspaceFolder.path;\n\t\tconst workspaceFolderVariants = [workspaceFolderPath];\n\t\tif (isWindows && workspaceFolder.scheme === Schemas.file) {\n\t\t\tworkspaceFolderVariants.push(extpath.toSlashes(workspaceFolderPath));\n\t\t}\n\n\t\tfor (const workspaceFolderVariant of workspaceFolderVariants) {\n\t\t\tconst validPathCharacterPattern = '[^\\\\s\\\\(\\\\):<>\"]';\n\t\t\tconst validPathCharacterOrSpacePattern = `(?:${validPathCharacterPattern}| ${validPathCharacterPattern})`;\n\t\t\tconst pathPattern = `${validPathCharacterOrSpacePattern}+\\\\.${validPathCharacterPattern}+`;\n\t\t\tconst strictPathPattern = `${validPathCharacterPattern}+`;\n\n\t\t\t// Example: /workspaces/express/server.js on line 8, column 13\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern}) on line ((\\\\d+)(, column (\\\\d+))?)`, 'gi'));\n\n\t\t\t// Example: /workspaces/express/server.js:line 8, column 13\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern}):line ((\\\\d+)(, column (\\\\d+))?)`, 'gi'));\n\n\t\t\t// Example: /workspaces/mankala/Features.ts(45): error\n\t\t\t// Example: /workspaces/mankala/Features.ts (45): error\n\t\t\t// Example: /workspaces/mankala/Features.ts(45,18): error\n\t\t\t// Example: /workspaces/mankala/Features.ts (45,18): error\n\t\t\t// Example: /workspaces/mankala/Features Special.ts (45,18): error\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern})(\\\\s?\\\\((\\\\d+)(,(\\\\d+))?)\\\\)`, 'gi'));\n\n\t\t\t// Example: at /workspaces/mankala/Game.ts\n\t\t\t// Example: at /workspaces/mankala/Game.ts:336\n\t\t\t// Example: at /workspaces/mankala/Game.ts:336:9\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${strictPathPattern})(:(\\\\d+))?(:(\\\\d+))?`, 'gi'));\n\t\t}\n\n\t\treturn patterns;\n\t}\n\n\t/**\n\t * Detect links. Made static to allow for tests.\n\t */\n\tstatic detectLinks(line: string, lineIndex: number, patterns: RegExp[], resourceCreator: IResourceCreator): ILink[] {\n\t\tconst links: ILink[] = [];\n\n\t\tpatterns.forEach(pattern => {\n\t\t\tpattern.lastIndex = 0; // the holy grail of software development\n\n\t\t\tlet match: RegExpExecArray | null;\n\t\t\tlet offset = 0;\n\t\t\twhile ((match = pattern.exec(line)) !== null) {\n\n\t\t\t\t// Convert the relative path information to a resource that we can use in links\n\t\t\t\tconst folderRelativePath = strings.rtrim(match[1], '.').replace(/\\\\/g, '/'); // remove trailing \".\" that likely indicate end of sentence\n\t\t\t\tlet resourceString: string | undefined;\n\t\t\t\ttry {\n\t\t\t\t\tconst resource = resourceCreator.toResource(folderRelativePath);\n\t\t\t\t\tif (resource) {\n\t\t\t\t\t\tresourceString = resource.toString();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tcontinue; // we might find an invalid URI and then we dont want to loose all other links\n\t\t\t\t}\n\n\t\t\t\t// Append line/col information to URI if matching\n\t\t\t\tif (match[3]) {\n\t\t\t\t\tconst lineNumber = match[3];\n\n\t\t\t\t\tif (match[5]) {\n\t\t\t\t\t\tconst columnNumber = match[5];\n\t\t\t\t\t\tresourceString = strings.format('{0}#{1},{2}', resourceString, lineNumber, columnNumber);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresourceString = strings.format('{0}#{1}', resourceString, lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst fullMatch = strings.rtrim(match[0], '.'); // remove trailing \".\" that likely indicate end of sentence\n\n\t\t\t\tconst index = line.indexOf(fullMatch, offset);\n\t\t\t\toffset += index + fullMatch.length;\n\n\t\t\t\tconst linkRange = {\n\t\t\t\t\tstartColumn: index + 1,\n\t\t\t\t\tstartLineNumber: lineIndex,\n\t\t\t\t\tendColumn: index + 1 + fullMatch.length,\n\t\t\t\t\tendLineNumber: lineIndex\n\t\t\t\t};\n\n\t\t\t\tif (links.some(link => Range.areIntersectingOrTouching(link.range, linkRange))) {\n\t\t\t\t\treturn; // Do not detect duplicate links\n\t\t\t\t}\n\n\t\t\t\tlinks.push({\n\t\t\t\t\trange: linkRange,\n\t\t\t\t\turl: resourceString\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn links;\n\t}\n}\n\nexport function create(ctx: IWorkerContext, createData: ICreateData): OutputLinkComputer {\n\treturn new OutputLinkComputer(ctx, createData);\n}\n"]}