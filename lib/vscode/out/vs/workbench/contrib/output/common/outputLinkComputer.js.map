{"version":3,"sources":["vs/workbench/contrib/output/common/fake","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/iterator.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/async.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/extpath.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/map.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/glob.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/network.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/base/common/resources.ts","vs/workbench/contrib/output/common/file:/repo/lib/vscode/src/vs/workbench/contrib/output/common/outputLinkComputer.ts"],"names":["__m","__M","deps","result","i","len","length","Iterator","exports","FIN","done","value","undefined","Iterable","first","iterable","Symbol","iterator","next","some","predicate","element","filter","map","fn","_empty","empty","single","fromArray","array","index","fromNativeIterator","it","[object Object]","from","elements","Array","isArray","forEach","collect","atMost","Number","POSITIVE_INFINITY","push","concat","iterators","this","chain","ChainableIterator","getSequenceIterator","arg","ArrayIterator","items","start","end","current","Math","min","ArrayNavigator","super","max","MappedIterator","MappedNavigator","navigator","previous","parent","last","isThenable","obj","then","createCancelablePromise","callback","source","cancellation_1","CancellationTokenSource","thenable","token","promise","Promise","resolve","reject","onCancellationRequested","errors","canceled","dispose","err","cancel","onfinally","finally","raceCancellation","defaultValue","race","raceTimeout","timeout","onTimeout","promiseResolve","timer","setTimeout","clearTimeout","asPromise","item","Throttler","activePromise","queuedPromise","queuedPromiseFactory","promiseFactory","onComplete","queue","c","e","Sequencer","promiseTask","Delayer","defaultDelay","completionPromise","doResolve","doReject","task","delay","cancelTimeout","ThrottledDelayer","delayer","throttler","trigger","isTriggered","millis","handle","Barrier","_isOpen","_promise","_completePromise","disposableTimeout","handler","lifecycle_1","toDisposable","ignoreErrors","_","sequence","promiseFactories","results","thenHandler","n","shouldStop","t","loop","factory","Limiter","maxDegreeOfParalellism","_size","outstandingPromises","runningPromises","_onFinished","event_1","Emitter","onFinished","event","size","consume","iLimitedTask","shift","consumed","fire","Queue","ResourceQueue","queues","Map","resource","key","toString","has","delete","set","get","clear","TimeoutTimer","runner","_token","setIfNotSet","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","bind","isScheduled","doRun","RunOnceWorker","units","unit","schedule","requestIdleCallback","cancelIdleCallback","dummyIdle","Object","freeze","didTimeout","timeRemaining","runWhenIdle","disposed","IdleValue","executor","_didRun","_executor","_value","_error","_handle","retry","async","retries","lastError","error","TaskSequentializer","taskId","_pending","pending","_a","onCancel","donePending","triggerNext","_next","run","promiseReject","isPathSeparator","code","toSlashes","osPath","replace","path_1","posix","sep","getRoot","path","firstLetter","charCodeAt","pos","slice","isWindowsDriveLetter","indexOf","isUNC","platform_1","isWindows","isNaN","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","char0","isValidBasename","name","isWindowsOS","invalidFileChars","test","lastIndex","trim","isEqual","pathA","pathB","ignoreCase","identityEquals","strings_1","equalsIgnoreCase","isEqualOrParent","candidate","separator","startsWithIgnoreCase","sepOffset","charAt","sanitizeFilePath","cwd","endsWith","isAbsolute","join","normalize","rtrim","isRootOrDriveLetter","pathNormalized","indexOfPath","toLowerCase","values","forEachable","keys","getOrSet","mapToString","entries","setToString","StringIterator","_pos","a","PathIterator","_splitOnBackslash","_from","_to","justSeps","ch","aPos","aLen","thisPos","cmp","substring","TernarySearchTreeNode","left","mid","right","TernarySearchTree","segments","_iter","_root","iter","reset","node","segment","val","hasNext","oldElement","stack","isEmpty","dir","pop","_nodeIterator","res","idx","data","_forEach","iterator_1","ResourceMap","toKey","clb","uri_1","URI","parse","k","resourceMap","Touch","LinkedMap","_map","_head","_tail","touch","addItemLast","addItemFirst","remove","removeItem","Error","callbackfn","thisArg","newSize","currentSize","LRUCache","limit","ratio","_limit","_ratio","checkTrim","trimOld","round","getEmptyExpression","create","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","splitGlobAware","pattern","splitChar","inBraces","inBrackets","curVal","char","T1","T2","T3","T3_2","T4","T5","CACHE","map_1","FALSE","NULL","parsePattern","arg1","options","patternKey","trimForExclusions","match","parsedPattern","wrapRelativePattern","base","substr","basename","exec","originalPattern","slashBase","backslashBase","basenames","patterns","allBasenames","trivia2","parsedPatterns","aggregateBasenameMatches","split","withBasenames","arrays","allPaths","reduce","all","trivia3","trivia4and5","regExp","RegExp","parseRegExp","regEx","every","s","previousSegmentWasGlobStar","braceVal","bracketVal","braceRegExp","strings","escapeRegExpCharacters","toRegExp","arg2","extpath","paths","relative","matchPathEnds","nativePath","nativePathEnd","isRelativePattern","resultPattern","expression","getOwnPropertyNames","when","hasSibling","matched","async_1","m","requiresSiblings","parseExpressionPattern","resultExpression","extname","parsedExpression","listToMap","list","rp","basenamePatterns","aggregate","aggregatedPatterns","hasSiblingPromiseFn","siblingsFn","siblings","hasSiblingFn","getBasenameTerms","patternOrExpression","getPathTerms","Schemas","inMemory","vscode","internal","walkThrough","walkThroughSnippet","http","https","file","mailto","untitled","command","vscodeRemote","vscodeRemoteResource","userData","vscodeCustomEditor","vscodeSettings","webviewPanel","RemoteAuthorities","_hosts","_ports","_connectionTokens","_preferredWebSchema","_delegate","schema","delegate","authority","host","port","connectionToken","uri","query","encodeURIComponent","scheme","platform","isWeb","window","location","pathname","originalFSPath","uriPath","hasToIgnoreCase","network_1","isLinux","parentCandidate","isEqualAuthority","a1","a2","hasTrailingPathSeparator","fsp","p","fsPath","relativePath","to","caseInsensitivePath","fromPath","toPath","getComparisonKey","with","fragment","basenameOrAuthority","second","ignoreFragment","p1","p2","dirname","console","joinPath","pathFragment","joinedPath","normalizePath","normalizedPath","isAbsolutePath","removeTrailingPathSeparator","addTrailingPathSeparator","isRootSep","resolvePath","newURI","distinctParents","resourceAccessor","candidateResource","otherItem","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","lastIndexOf","property","mime","ResourceGlobMatcher","globalExpression","rootExpressions","expressionsByRoot","forPaths","glob_1","root","rootExpression","findSubstr","toLocalResource","OutputLinkComputer","ctx","createData","computePatterns","workspaceFolders","sort","resourceStrA","resourceStrB","resourceStr","workspaceFolder","createPatterns","models","getMirrorModels","arrays_1","find","model","getModel","links","lines","getValue","folderUri","folderPatterns","resourceCreator","toResource","folderRelativePath","resources","detectLinks","workspaceFolderPath","workspaceFolderVariants","workspaceFolderVariant","validPathCharacterPattern","pathPattern","strictPathPattern","line","lineIndex","offset","resourceString","lineNumber","columnNumber","format","fullMatch","linkRange","startColumn","startLineNumber","endColumn","endLineNumber","link","range_1","Range","areIntersectingOrTouching","range","url","call"],"mappings":"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","file":"outputLinkComputer.js","sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IteratorDefinedResult<T> {\n\treadonly done: false;\n\treadonly value: T;\n}\nexport interface IteratorUndefinedResult {\n\treadonly done: true;\n\treadonly value: undefined;\n}\nexport const FIN: IteratorUndefinedResult = { done: true, value: undefined };\nexport type IteratorResult<T> = IteratorDefinedResult<T> | IteratorUndefinedResult;\n\nexport interface Iterator<T> {\n\tnext(): IteratorResult<T>;\n}\n\ninterface NativeIteratorYieldResult<TYield> {\n\tdone?: false;\n\tvalue: TYield;\n}\n\ninterface NativeIteratorReturnResult<TReturn> {\n\tdone: true;\n\tvalue: TReturn;\n}\n\ntype NativeIteratorResult<T, TReturn = any> = NativeIteratorYieldResult<T> | NativeIteratorReturnResult<TReturn>;\n\nexport interface NativeIterator<T> {\n\tnext(): NativeIteratorResult<T>;\n}\n\nexport namespace Iterable {\n\n\texport function first<T>(iterable: Iterable<T>): T | undefined {\n\t\treturn iterable[Symbol.iterator]().next().value;\n\t}\n\n\texport function some<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): boolean {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\texport function* filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T> {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\tyield element;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function* map<T, R>(iterable: Iterable<T>, fn: (t: T) => R): Iterable<R> {\n\t\tfor (const element of iterable) {\n\t\t\tyield fn(element);\n\t\t}\n\t}\n}\n\nexport module Iterator {\n\tconst _empty: Iterator<any> = {\n\t\tnext() {\n\t\t\treturn FIN;\n\t\t}\n\t};\n\n\texport function empty<T>(): Iterator<T> {\n\t\treturn _empty;\n\t}\n\n\texport function single<T>(value: T): Iterator<T> {\n\t\tlet done = false;\n\n\t\treturn {\n\t\t\tnext(): IteratorResult<T> {\n\t\t\t\tif (done) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t}\n\n\t\t\t\tdone = true;\n\t\t\t\treturn { done: false, value };\n\t\t\t}\n\t\t};\n\t}\n\n\texport function fromArray<T>(array: ReadonlyArray<T>, index = 0, length = array.length): Iterator<T> {\n\t\treturn {\n\t\t\tnext(): IteratorResult<T> {\n\t\t\t\tif (index >= length) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t}\n\n\t\t\t\treturn { done: false, value: array[index++] };\n\t\t\t}\n\t\t};\n\t}\n\n\texport function fromNativeIterator<T>(it: NativeIterator<T>): Iterator<T> {\n\t\treturn {\n\t\t\tnext(): IteratorResult<T> {\n\t\t\t\tconst result = it.next();\n\n\t\t\t\tif (result.done) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t}\n\n\t\t\t\treturn { done: false, value: result.value };\n\t\t\t}\n\t\t};\n\t}\n\n\texport function from<T>(elements: Iterator<T> | T[] | undefined): Iterator<T> {\n\t\tif (!elements) {\n\t\t\treturn Iterator.empty();\n\t\t} else if (Array.isArray(elements)) {\n\t\t\treturn Iterator.fromArray(elements);\n\t\t} else {\n\t\t\treturn elements;\n\t\t}\n\t}\n\n\texport function map<T, R>(iterator: Iterator<T>, fn: (t: T) => R): Iterator<R> {\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\tconst element = iterator.next();\n\t\t\t\tif (element.done) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t} else {\n\t\t\t\t\treturn { done: false, value: fn(element.value) };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\texport function filter<T>(iterator: Iterator<T>, fn: (t: T) => boolean): Iterator<T> {\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst element = iterator.next();\n\t\t\t\t\tif (element.done) {\n\t\t\t\t\t\treturn FIN;\n\t\t\t\t\t}\n\t\t\t\t\tif (fn(element.value)) {\n\t\t\t\t\t\treturn { done: false, value: element.value };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\texport function some<T>(iterator: Iterator<T> | NativeIterator<T>, fn: (t: T) => boolean): boolean {\n\t\twhile (true) {\n\t\t\tconst element = iterator.next();\n\t\t\tif (element.done) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (fn(element.value)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function forEach<T>(iterator: Iterator<T>, fn: (t: T) => void): void {\n\t\tfor (let next = iterator.next(); !next.done; next = iterator.next()) {\n\t\t\tfn(next.value);\n\t\t}\n\t}\n\n\texport function collect<T>(iterator: Iterator<T>, atMost: number = Number.POSITIVE_INFINITY): T[] {\n\t\tconst result: T[] = [];\n\n\t\tif (atMost === 0) {\n\t\t\treturn result;\n\t\t}\n\n\t\tlet i = 0;\n\n\t\tfor (let next = iterator.next(); !next.done; next = iterator.next()) {\n\t\t\tresult.push(next.value);\n\n\t\t\tif (++i >= atMost) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\texport function concat<T>(...iterators: Iterator<T>[]): Iterator<T> {\n\t\tlet i = 0;\n\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\tif (i >= iterators.length) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t}\n\n\t\t\t\tconst iterator = iterators[i];\n\t\t\t\tconst result = iterator.next();\n\n\t\t\t\tif (result.done) {\n\t\t\t\t\ti++;\n\t\t\t\t\treturn this.next();\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\t}\n\n\texport function chain<T>(iterator: Iterator<T>): ChainableIterator<T> {\n\t\treturn new ChainableIterator(iterator);\n\t}\n}\n\nexport class ChainableIterator<T> implements Iterator<T> {\n\n\tconstructor(private it: Iterator<T>) { }\n\n\tnext(): IteratorResult<T> { return this.it.next(); }\n\tmap<R>(fn: (t: T) => R): ChainableIterator<R> { return new ChainableIterator(Iterator.map(this.it, fn)); }\n\tfilter(fn: (t: T) => boolean): ChainableIterator<T> { return new ChainableIterator(Iterator.filter(this.it, fn)); }\n}\n\nexport type ISequence<T> = Iterator<T> | T[];\n\nexport function getSequenceIterator<T>(arg: ISequence<T> | undefined): Iterator<T> {\n\tif (Array.isArray(arg)) {\n\t\treturn Iterator.fromArray(arg);\n\t} else if (!arg) {\n\t\treturn Iterator.empty();\n\t} else {\n\t\treturn arg;\n\t}\n}\n\nexport interface INextIterator<T> {\n\tnext(): T | null;\n}\n\nexport class ArrayIterator<T> implements INextIterator<T> {\n\n\tprivate readonly items: readonly T[];\n\tprotected start: number;\n\tprotected end: number;\n\tprotected index: number;\n\n\tconstructor(items: readonly T[], start: number = 0, end: number = items.length, index = start - 1) {\n\t\tthis.items = items;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.index = index;\n\t}\n\n\tpublic first(): T | null {\n\t\tthis.index = this.start;\n\t\treturn this.current();\n\t}\n\n\tpublic next(): T | null {\n\t\tthis.index = Math.min(this.index + 1, this.end);\n\t\treturn this.current();\n\t}\n\n\tprotected current(): T | null {\n\t\tif (this.index === this.start - 1 || this.index === this.end) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.items[this.index];\n\t}\n}\n\nexport class ArrayNavigator<T> extends ArrayIterator<T> implements INavigator<T> {\n\n\tconstructor(items: readonly T[], start: number = 0, end: number = items.length, index = start - 1) {\n\t\tsuper(items, start, end, index);\n\t}\n\n\tpublic current(): T | null {\n\t\treturn super.current();\n\t}\n\n\tpublic previous(): T | null {\n\t\tthis.index = Math.max(this.index - 1, this.start - 1);\n\t\treturn this.current();\n\t}\n\n\tpublic first(): T | null {\n\t\tthis.index = this.start;\n\t\treturn this.current();\n\t}\n\n\tpublic last(): T | null {\n\t\tthis.index = this.end - 1;\n\t\treturn this.current();\n\t}\n\n\tpublic parent(): T | null {\n\t\treturn null;\n\t}\n}\n\nexport class MappedIterator<T, R> implements INextIterator<R> {\n\n\tconstructor(protected iterator: INextIterator<T>, protected fn: (item: T | null) => R) {\n\t\t// noop\n\t}\n\n\tnext() { return this.fn(this.iterator.next()); }\n}\n\nexport interface INavigator<T> extends INextIterator<T> {\n\tcurrent(): T | null;\n\tprevious(): T | null;\n\tparent(): T | null;\n\tfirst(): T | null;\n\tlast(): T | null;\n\tnext(): T | null;\n}\n\nexport class MappedNavigator<T, R> extends MappedIterator<T, R> implements INavigator<R> {\n\n\tconstructor(protected navigator: INavigator<T>, fn: (item: T | null) => R) {\n\t\tsuper(navigator, fn);\n\t}\n\n\tcurrent() { return this.fn(this.navigator.current()); }\n\tprevious() { return this.fn(this.navigator.previous()); }\n\tparent() { return this.fn(this.navigator.parent()); }\n\tfirst() { return this.fn(this.navigator.first()); }\n\tlast() { return this.fn(this.navigator.last()); }\n\tnext() { return this.fn(this.navigator.next()); }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\n\nexport function isThenable<T>(obj: any): obj is Promise<T> {\n\treturn obj && typeof (<Promise<any>>obj).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tsource.token.onCancellationRequested(() => {\n\t\t\treject(errors.canceled());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T> {\n\treturn Promise.race([promise, new Promise<T>(resolve => token.onCancellationRequested(() => resolve(defaultValue)))]);\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T> {\n\tlet promiseResolve: (() => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.();\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(c => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(c);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((c, e) => {\n\t\t\t\tthis.queuedPromise!.then(c, e);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((c, e) => {\n\t\t\tthis.activePromise!.then((result: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tc(result);\n\t\t\t}, (err: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\te(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<any> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask());\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate timeout: any;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number) {\n\t\tthis.timeout = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay: number = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((c, e) => {\n\t\t\t\tthis.doResolve = c;\n\t\t\t\tthis.doReject = e;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tthis.timeout = setTimeout(() => {\n\t\t\tthis.timeout = null;\n\t\t\tif (this.doResolve) {\n\t\t\t\tthis.doResolve(null);\n\t\t\t}\n\t\t}, delay);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.timeout !== null;\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tif (this.doReject) {\n\t\t\t\tthis.doReject(errors.canceled());\n\t\t\t}\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tif (this.timeout !== null) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancelTimeout();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as any as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(resolve, millis);\n\t\ttoken.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\treject(errors.canceled());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\nexport function ignoreErrors<T>(promise: Promise<T>): Promise<T | undefined> {\n\treturn promise.then(undefined, _ => undefined);\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value?: T | Promise<T>) => void;\n\te: (error?: any) => void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> {\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate maxDegreeOfParalellism: number;\n\tprivate outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onFinished: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onFinished = new Emitter<void>();\n\t}\n\n\tget onFinished(): Event<void> {\n\t\treturn this._onFinished.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t\t// return this.runningPromises + this.outstandingPromises.length;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onFinished.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onFinished.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tqueueFor(resource: URI): Queue<void> {\n\t\tconst key = resource.toString();\n\t\tif (!this.queues.has(key)) {\n\t\t\tconst queue = new Queue<void>();\n\t\t\tqueue.onFinished(() => {\n\t\t\t\tqueue.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t});\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn this.queues.get(key)!;\n\t}\n\n\tdispose(): void {\n\t\tthis.queues.forEach(queue => queue.dispose());\n\t\tthis.queues.clear();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler {\n\n\tprotected runner: ((...args: any[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, timeout: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = timeout;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tif (this.runner) {\n\t\t\tthis.runner();\n\t\t}\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tif (this.runner) {\n\t\t\tthis.runner(units);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\tconst dummyIdle: IdleDeadline = Object.freeze({\n\t\t\tdidTimeout: true,\n\t\t\ttimeRemaining() { return 15; }\n\t\t});\n\t\trunWhenIdle = (runner) => {\n\t\t\tconst handle = setTimeout(() => runner(dummyIdle));\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: any;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tgetValue(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IPendingTask {\n\ttaskId: number;\n\tcancel: () => void;\n\tpromise: Promise<void>;\n}\n\ninterface ISequentialTask {\n\tpromise: Promise<void>;\n\tpromiseResolve: () => void;\n\tpromiseReject: (error: Error) => void;\n\trun: () => Promise<void>;\n}\n\nexport interface ITaskSequentializerWithPendingTask {\n\treadonly pending: Promise<void>;\n}\n\nexport class TaskSequentializer {\n\tprivate _pending?: IPendingTask;\n\tprivate _next?: ISequentialTask;\n\n\thasPending(taskId?: number): this is ITaskSequentializerWithPendingTask {\n\t\tif (!this._pending) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._pending.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._pending;\n\t}\n\n\tget pending(): Promise<void> | undefined {\n\t\treturn this._pending ? this._pending.promise : undefined;\n\t}\n\n\tcancelPending(): void {\n\t\tthis._pending?.cancel();\n\t}\n\n\tsetPending(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._pending = { taskId: taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.donePending(taskId), () => this.donePending(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate donePending(taskId: number): void {\n\t\tif (this._pending && taskId === this._pending.taskId) {\n\n\t\t\t// only set pending to done if the promise finished that is associated with that taskId\n\t\t\tthis._pending = undefined;\n\n\t\t\t// schedule the next task now that we are free if we have any\n\t\t\tthis.triggerNext();\n\t\t}\n\t}\n\n\tprivate triggerNext(): void {\n\t\tif (this._next) {\n\t\t\tconst next = this._next;\n\t\t\tthis._next = undefined;\n\n\t\t\t// Run next task and complete on the associated promise\n\t\t\tnext.run().then(next.promiseResolve, next.promiseReject);\n\t\t}\n\t}\n\n\tsetNext(run: () => Promise<void>): Promise<void> {\n\n\t\t// this is our first next task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._next) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._next = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous next task, just overwrite it\n\t\telse {\n\t\t\tthis._next.run = run;\n\t\t}\n\n\t\treturn this._next.promise;\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { startsWithIgnoreCase, equalsIgnoreCase, rtrim } from 'vs/base/common/strings';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { sep, posix, isAbsolute, join, normalize } from 'vs/base/common/path';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(1);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(pos + 1);\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\nexport function isEqualOrParent(path: string, candidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (path === candidate) {\n\t\treturn true;\n\t}\n\n\tif (!path || !candidate) {\n\t\treturn false;\n\t}\n\n\tif (candidate.length > path.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(path, candidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (candidate.length === path.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = candidate.length;\n\t\tif (candidate.charAt(candidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn path.charAt(sepOffset) === separator;\n\t}\n\n\tif (candidate.charAt(candidate.length - 1) !== separator) {\n\t\tcandidate += separator;\n\t}\n\n\treturn path.indexOf(candidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isWindowsDriveLetter(pathNormalized.charCodeAt(0))\n\t\t\t&& pathNormalized.charCodeAt(1) === CharCode.Colon\n\t\t\t&& (path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { FIN } from './iterator';\n\n/**\n * @deprecated ES6: use `[...SetOrMap.values()]`\n */\nexport function values<V = any>(set: Set<V>): V[];\nexport function values<K = any, V = any>(map: Map<K, V>): V[];\nexport function values<V>(forEachable: { forEach(callback: (value: V, ...more: any[]) => any): void }): V[] {\n\tconst result: V[] = [];\n\tforEachable.forEach(value => result.push(value));\n\treturn result;\n}\n\n/**\n * @deprecated ES6: use `[...map.keys()]`\n */\nexport function keys<K, V>(map: Map<K, V>): K[] {\n\tconst result: K[] = [];\n\tmap.forEach((_value, key) => result.push(key));\n\n\treturn result;\n}\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\nexport interface IKeyIterator {\n\treset(key: string): this;\n\tnext(): this;\n\n\thasNext(): boolean;\n\tcmp(a: string): number;\n\tvalue(): string;\n}\n\nexport class StringIterator implements IKeyIterator {\n\n\tprivate _value: string = '';\n\tprivate _pos: number = 0;\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._pos = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tthis._pos += 1;\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._pos < this._value.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tconst aCode = a.charCodeAt(0);\n\t\tconst thisCode = this._value.charCodeAt(this._pos);\n\t\treturn aCode - thisCode;\n\t}\n\n\tvalue(): string {\n\t\treturn this._value[this._pos];\n\t}\n}\n\nexport class PathIterator implements IKeyIterator {\n\n\tprivate _value!: string;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(private _splitOnBackslash: boolean = true) { }\n\n\treset(key: string): this {\n\t\tthis._value = key.replace(/\\\\$|\\/$/, '');\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._value.length;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._value.length; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\n\t\tlet aPos = 0;\n\t\tconst aLen = a.length;\n\t\tlet thisPos = this._from;\n\n\t\twhile (aPos < aLen && thisPos < this._to) {\n\t\t\tconst cmp = a.charCodeAt(aPos) - this._value.charCodeAt(thisPos);\n\t\t\tif (cmp !== 0) {\n\t\t\t\treturn cmp;\n\t\t\t}\n\t\t\taPos += 1;\n\t\t\tthisPos += 1;\n\t\t}\n\n\t\tif (aLen === this._to - this._from) {\n\t\t\treturn 0;\n\t\t} else if (aPos < aLen) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nclass TernarySearchTreeNode<E> {\n\tsegment!: string;\n\tvalue: E | undefined;\n\tkey!: string;\n\tleft: TernarySearchTreeNode<E> | undefined;\n\tmid: TernarySearchTreeNode<E> | undefined;\n\tright: TernarySearchTreeNode<E> | undefined;\n\n\tisEmpty(): boolean {\n\t\treturn !this.left && !this.mid && !this.right && !this.value;\n\t}\n}\n\nexport class TernarySearchTree<E> {\n\n\tstatic forPaths<E>(): TernarySearchTree<E> {\n\t\treturn new TernarySearchTree<E>(new PathIterator());\n\t}\n\n\tstatic forStrings<E>(): TernarySearchTree<E> {\n\t\treturn new TernarySearchTree<E>(new StringIterator());\n\t}\n\n\tprivate _iter: IKeyIterator;\n\tprivate _root: TernarySearchTreeNode<E> | undefined;\n\n\tconstructor(segments: IKeyIterator) {\n\t\tthis._iter = segments;\n\t}\n\n\tclear(): void {\n\t\tthis._root = undefined;\n\t}\n\n\tset(key: string, element: E): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node: TernarySearchTreeNode<E>;\n\n\t\tif (!this._root) {\n\t\t\tthis._root = new TernarySearchTreeNode<E>();\n\t\t\tthis._root.segment = iter.value();\n\t\t}\n\n\t\tnode = this._root;\n\t\twhile (true) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tif (!node.left) {\n\t\t\t\t\tnode.left = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.left.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.left;\n\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tif (!node.right) {\n\t\t\t\t\tnode.right = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.right.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.right;\n\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tnode.mid = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.mid.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst oldElement = node.value;\n\t\tnode.value = element;\n\t\tnode.key = key;\n\t\treturn oldElement;\n\t}\n\n\tget(key: string): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node ? node.value : undefined;\n\t}\n\n\tdelete(key: string): void {\n\n\t\tconst iter = this._iter.reset(key);\n\t\tconst stack: [-1 | 0 | 1, TernarySearchTreeNode<E>][] = [];\n\t\tlet node = this._root;\n\n\t\t// find and unset node\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tstack.push([1, node]);\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tstack.push([-1, node]);\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tstack.push([0, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// remove element\n\t\t\t\tnode.value = undefined;\n\n\t\t\t\t// clean up empty nodes\n\t\t\t\twhile (stack.length > 0 && node.isEmpty()) {\n\t\t\t\t\tlet [dir, parent] = stack.pop()!;\n\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\tcase 1: parent.left = undefined; break;\n\t\t\t\t\t\tcase 0: parent.mid = undefined; break;\n\t\t\t\t\t\tcase -1: parent.right = undefined; break;\n\t\t\t\t\t}\n\t\t\t\t\tnode = parent;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfindSubstr(key: string): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\tlet candidate: E | undefined = undefined;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tcandidate = node.value || candidate;\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node && node.value || candidate;\n\t}\n\n\tfindSuperstr(key: string): Iterator<E> | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// collect\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\treturn this._nodeIterator(node.mid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _nodeIterator(node: TernarySearchTreeNode<E>): Iterator<E> {\n\t\tlet res: { done: false; value: E; };\n\t\tlet idx: number;\n\t\tlet data: E[];\n\t\tconst next = (): IteratorResult<E> => {\n\t\t\tif (!data) {\n\t\t\t\t// lazy till first invocation\n\t\t\t\tdata = [];\n\t\t\t\tidx = 0;\n\t\t\t\tthis._forEach(node, value => data.push(value));\n\t\t\t}\n\t\t\tif (idx >= data.length) {\n\t\t\t\treturn FIN;\n\t\t\t}\n\n\t\t\tif (!res) {\n\t\t\t\tres = { done: false, value: data[idx++] };\n\t\t\t} else {\n\t\t\t\tres.value = data[idx++];\n\t\t\t}\n\t\t\treturn res;\n\t\t};\n\t\treturn { next };\n\t}\n\n\tforEach(callback: (value: E, index: string) => any) {\n\t\tthis._forEach(this._root, callback);\n\t}\n\n\tprivate _forEach(node: TernarySearchTreeNode<E> | undefined, callback: (value: E, index: string) => any) {\n\t\tif (node) {\n\t\t\t// left\n\t\t\tthis._forEach(node.left, callback);\n\n\t\t\t// node\n\t\t\tif (node.value) {\n\t\t\t\t// callback(node.value, this._iter.join(parts));\n\t\t\t\tcallback(node.value, node.key);\n\t\t\t}\n\t\t\t// mid\n\t\t\tthis._forEach(node.mid, callback);\n\n\t\t\t// right\n\t\t\tthis._forEach(node.right, callback);\n\t\t}\n\t}\n}\n\nexport class ResourceMap<T> {\n\n\tprotected readonly map: Map<string, T>;\n\tprotected readonly ignoreCase?: boolean;\n\n\tconstructor() {\n\t\tthis.map = new Map<string, T>();\n\t\tthis.ignoreCase = false; // in the future this should be an uri-comparator\n\t}\n\n\tset(resource: URI, value: T): void {\n\t\tthis.map.set(this.toKey(resource), value);\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource));\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI) => void): void {\n\t\tthis.map.forEach((value, index) => clb(value, URI.parse(index)));\n\t}\n\n\tvalues(): T[] {\n\t\treturn values(this.map);\n\t}\n\n\tprivate toKey(resource: URI): string {\n\t\tlet key = resource.toString();\n\t\tif (this.ignoreCase) {\n\t\t\tkey = key.toLowerCase();\n\t\t}\n\n\t\treturn key;\n\t}\n\n\tkeys(): URI[] {\n\t\treturn keys(this.map).map(k => URI.parse(k));\n\t}\n\n\tclone(): ResourceMap<T> {\n\t\tconst resourceMap = new ResourceMap<T>();\n\n\t\tthis.map.forEach((value, key) => resourceMap.map.set(key, value));\n\n\t\treturn resourceMap;\n\t}\n}\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> {\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): void {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tvalues(): V[] {\n\t\tconst result: V[] = [];\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tresult.push(current.value);\n\t\t\tcurrent = current.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\tkeys(): K[] {\n\t\tconst result: K[] = [];\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tresult.push(current.key);\n\t\t\tcurrent = current.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* VS Code / Monaco editor runs on es5 which has no Symbol.iterator\n\tkeys(): IterableIterator<K> {\n\t\tconst current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext():IteratorResult<K> {\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext():IteratorResult<V> {\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\t*/\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nexport class LRUCache<K, V> extends LinkedMap<K, V> {\n\n\tprivate _limit: number;\n\tprivate _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn super.get(key, Touch.AsNew);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\tset(key: K, value: V): void {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\tthis.checkTrim();\n\t}\n\n\tprivate checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trimOld(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport * as strings from 'vs/base/common/strings';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { LRUCache } from 'vs/base/common/map';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isThenable } from 'vs/base/common/async';\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport interface IRelativePattern {\n\tbase: string;\n\tpattern: string;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\nexport interface SiblingClause {\n\twhen: string;\n}\n\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(s => s === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Globstar is special\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (!previousSegmentWasGlobStar) {\n\t\t\t\t\tregEx += starsToRegExp(2);\n\t\t\t\t\tpreviousSegmentWasGlobStar = true;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// States\n\t\t\tlet inBraces = false;\n\t\t\tlet braceVal = '';\n\n\t\t\tlet inBrackets = false;\n\t\t\tlet bracketVal = '';\n\n\t\t\tfor (const char of segment) {\n\t\t\t\t// Support brace expansion\n\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\tbraceVal += char;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Support brackets\n\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t// range operator\n\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\tres = char;\n\t\t\t\t\t}\n\n\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\tres = '^';\n\t\t\t\t\t}\n\n\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t}\n\n\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = strings.escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\n\t\t\t\t\tbracketVal += res;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (char) {\n\t\t\t\t\tcase '{':\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '}':\n\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n\n\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tregEx += strings.escapeRegExpCharacters(char);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n\t\t\t// a folder called \"something\" to match as well.\n\t\t\t// However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n\t\t\t// is to match 0-N segments.\n\t\t\tif (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n\t\t\t\tregEx += PATH_REGEX;\n\t\t\t}\n\n\t\t\t// reset state\n\t\t\tpreviousSegmentWasGlobStar = false;\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trival glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t   \t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t   \t\t\t// **/something\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; \t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t   \t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t   \t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The ParsedExpression returns a Promise iff hasSibling returns a Promise.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\nexport interface IGlobOptions {\n\t/**\n\t * Simplify patterns for use as exclusion filters during tree traversal to skip entire subtrees. Cannot be used outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle IRelativePattern\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivias\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\n\t\tconst base = pattern.substr(4); // '**/*'.length === 4\n\t\tparsedPattern = function (path, basename) {\n\t\t\treturn typeof path === 'string' && path.endsWith(base) ? pattern : null;\n\t\t};\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\treturn function (path, basename) {\n\t\tif (!extpath.isEqualOrParent(path, arg2.base)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn parsedPattern(paths.relative(arg2.base, path), basename);\n\t};\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, originalPattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\tconst parsedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (basename) {\n\t\t\treturn basename === base ? originalPattern : null;\n\t\t}\n\t\treturn path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;\n\t};\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [originalPattern];\n\tparsedPattern.allBasenames = basenames;\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\tif (n === 1) {\n\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t}\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif ((<ParsedStringPattern>parsedPatterns[i])(path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(path: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\n\tconst nativePathEnd = paths.sep + nativePath;\n\tconst parsedPattern: ParsedStringPattern = matchPathEnds ? function (path, basename) {\n\t\treturn typeof path === 'string' && (path === nativePath || path.endsWith(nativePathEnd)) ? pattern : null;\n\t} : function (path, basename) {\n\t\treturn typeof path === 'string' && path === nativePath ? pattern : null;\n\t};\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(<IExpression>arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[]; } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([]))\n\t\t\t\t.then(list => list ? listToMap(list) : {});\n\t\t}\n\t\treturn siblings.then(map => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern;\n\n\treturn rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (n === 1) {\n\t\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\t// Pattern matches path\n\t\t\t\tconst result = (<ParsedStringPattern>parsedPatterns[i])(path, basename);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!basename) {\n\t\t\t\t\tbasename = paths.basename(path);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = basename.substr(0, basename.length - paths.extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst result = parsedPattern(path, basename, name, hasSibling);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = (<SiblingClause>value).when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(m => m ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\t\t\tresult.requiresSiblings = true;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is Anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, <string[]>[]);\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, <string[]>[]);\n\t}\n\tconst aggregate: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbasename = path.substr(i);\n\t\t}\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\treturn aggregatedPatterns;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport * as platform from 'vs/base/common/platform';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const userData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const webviewPanel = 'webview-panel';\n}\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined; } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined; } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined; } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\treturn this._delegate(uri);\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\t// const port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&tkn=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\t// NOTE@coder: Changed this to work against the current path.\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: window.location.host,\n\t\t\tpath: `${window.location.pathname.replace(/\\/+$/, '')}/vscode-remote-resource`,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { URI } from 'vs/base/common/uri';\nimport { equalsIgnoreCase } from 'vs/base/common/strings';\nimport { Schemas } from 'vs/base/common/network';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { ParsedExpression, IExpression, parse } from 'vs/base/common/glob';\nimport { TernarySearchTree } from 'vs/base/common/map';\n\nexport function originalFSPath(uri: URI): string {\n\tlet value: string;\n\tconst uriPath = uri.path;\n\tif (uri.authority && uriPath.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uriPath}`;\n\t} else if (\n\t\tisWindows\n\t\t&& uriPath.charCodeAt(0) === CharCode.Slash\n\t\t&& extpath.isWindowsDriveLetter(uriPath.charCodeAt(1))\n\t\t&& uriPath.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tvalue = uriPath.substr(1);\n\t} else {\n\t\t// other path\n\t\tvalue = uriPath;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n * URI queries are included, fragments are ignored.\n */\nexport function getComparisonKey(resource: URI, caseInsensitivePath = hasToIgnoreCase(resource)): string {\n\tlet path = resource.path || '/';\n\tif (caseInsensitivePath) {\n\t\tpath = path.toLowerCase();\n\t}\n\treturn resource.with({ authority: resource.authority.toLowerCase(), path: path, fragment: null }).toString();\n}\n\nexport function hasToIgnoreCase(resource: URI | undefined): boolean {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn resource && resource.scheme === Schemas.file ? !isLinux : true;\n}\n\nexport function basenameOrAuthority(resource: URI): string {\n\treturn basename(resource) || resource.authority;\n}\n\n/**\n * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n * URI queries must match, fragments are ignored.\n * @param base A uri which is \"longer\"\n * @param parentCandidate A uri which is \"shorter\" then `base`\n */\nexport function isEqualOrParent(base: URI, parentCandidate: URI, ignoreCase = hasToIgnoreCase(base)): boolean {\n\tif (base.scheme === parentCandidate.scheme) {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), ignoreCase) && base.query === parentCandidate.query;\n\t\t}\n\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\treturn extpath.isEqualOrParent(base.path || '/', parentCandidate.path || '/', ignoreCase, '/') && base.query === parentCandidate.query;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Tests whether the two authorities are the same\n */\nexport function isEqualAuthority(a1: string, a2: string) {\n\treturn a1 === a2 || equalsIgnoreCase(a1, a2);\n}\n\n/**\n * Tests whether two resources are the same.  URI queries must match, fragments are ignored unless requested.\n */\nexport function isEqual(first: URI | undefined, second: URI | undefined, caseInsensitivePath = hasToIgnoreCase(first), ignoreFragment = true): boolean {\n\tif (first === second) {\n\t\treturn true;\n\t}\n\n\tif (!first || !second) {\n\t\treturn false;\n\t}\n\n\tif (first.scheme !== second.scheme || !isEqualAuthority(first.authority, second.authority)) {\n\t\treturn false;\n\t}\n\n\tconst p1 = first.path || '/', p2 = second.path || '/';\n\treturn (p1 === p2 || caseInsensitivePath && equalsIgnoreCase(p1, p2)) && first.query === second.query && (ignoreFragment || first.fragment === second.fragment);\n}\n\nexport function basename(resource: URI): string {\n\treturn paths.posix.basename(resource.path);\n}\n\nexport function extname(resource: URI): string {\n\treturn paths.posix.extname(resource.path);\n}\n\n/**\n * Return a URI representing the directory of a URI path.\n *\n * @param resource The input URI.\n * @returns The URI representing the directory of the input URI.\n */\nexport function dirname(resource: URI): URI {\n\tif (resource.path.length === 0) {\n\t\treturn resource;\n\t}\n\tlet dirname;\n\tif (resource.scheme === Schemas.file) {\n\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t} else {\n\t\tdirname = paths.posix.dirname(resource.path);\n\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t}\n\t}\n\treturn resource.with({\n\t\tpath: dirname\n\t});\n}\n\n/**\n * Join a URI path with path fragments and normalizes the resulting path.\n *\n * @param resource The input URI.\n * @param pathFragment The path fragment to add to the URI path.\n * @returns The resulting URI.\n */\nexport function joinPath(resource: URI, ...pathFragment: string[]): URI {\n\tlet joinedPath: string;\n\tif (resource.scheme === 'file') {\n\t\tjoinedPath = URI.file(paths.join(originalFSPath(resource), ...pathFragment)).path;\n\t} else {\n\t\tjoinedPath = paths.posix.join(resource.path || '/', ...pathFragment);\n\t}\n\treturn resource.with({\n\t\tpath: joinedPath\n\t});\n}\n\n/**\n * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n *\n * @param resource The URI to normalize the path.\n * @returns The URI with the normalized path.\n */\nexport function normalizePath(resource: URI): URI {\n\tif (!resource.path.length) {\n\t\treturn resource;\n\t}\n\tlet normalizedPath: string;\n\tif (resource.scheme === Schemas.file) {\n\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t} else {\n\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t}\n\treturn resource.with({\n\t\tpath: normalizedPath\n\t});\n}\n\n/**\n * Returns true if the URI path is absolute.\n */\nexport function isAbsolutePath(resource: URI): boolean {\n\treturn !!resource.path && resource.path[0] === '/';\n}\n\n/**\n * Returns true if the URI path has a trailing path separator\n */\nexport function hasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\tif (resource.scheme === Schemas.file) {\n\t\tconst fsp = originalFSPath(resource);\n\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t} else {\n\t\tconst p = resource.path;\n\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t}\n}\n\n/**\n * Removes a trailing path separator, if there's one.\n * Important: Doesn't remove the first slash, it would make the URI invalid\n */\nexport function removeTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t}\n\treturn resource;\n}\n\n/**\n * Adds a trailing path separator to the URI if there isn't one already.\n * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n */\nexport function addTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\tlet isRootSep: boolean = false;\n\tif (resource.scheme === Schemas.file) {\n\t\tconst fsp = originalFSPath(resource);\n\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t} else {\n\t\tsep = '/';\n\t\tconst p = resource.path;\n\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t}\n\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\treturn resource.with({ path: resource.path + '/' });\n\t}\n\treturn resource;\n}\n\n/**\n * Returns a relative path between two URIs. If the URIs don't have the same schema or authority, `undefined` is returned.\n * The returned relative path always uses forward slashes.\n */\nexport function relativePath(from: URI, to: URI, caseInsensitivePath = hasToIgnoreCase(from)): string | undefined {\n\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\treturn undefined;\n\t}\n\tif (from.scheme === Schemas.file) {\n\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t}\n\tlet fromPath = from.path || '/', toPath = to.path || '/';\n\tif (caseInsensitivePath) {\n\t\t// make casing of fromPath match toPath\n\t\tlet i = 0;\n\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t}\n\treturn paths.posix.relative(fromPath, toPath);\n}\n\n/**\n * Resolves an absolute or relative path against a base URI.\n * The path can be relative or absolute posix or a Windows path\n */\nexport function resolvePath(base: URI, path: string): URI {\n\tif (base.scheme === Schemas.file) {\n\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\treturn base.with({\n\t\t\tauthority: newURI.authority,\n\t\t\tpath: newURI.path\n\t\t});\n\t}\n\tif (path.indexOf('/') === -1) { // no slashes? it's likely a Windows path\n\t\tpath = extpath.toSlashes(path);\n\t\tif (/^[a-zA-Z]:(\\/|$)/.test(path)) { // starts with a drive letter\n\t\t\tpath = '/' + path;\n\t\t}\n\t}\n\treturn base.with({\n\t\tpath: paths.posix.resolve(base.path, path)\n\t});\n}\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport class ResourceGlobMatcher {\n\n\tprivate readonly globalExpression: ParsedExpression;\n\tprivate readonly expressionsByRoot: TernarySearchTree<{ root: URI, expression: ParsedExpression }> = TernarySearchTree.forPaths<{ root: URI, expression: ParsedExpression }>();\n\n\tconstructor(\n\t\tglobalExpression: IExpression,\n\t\trootExpressions: { root: URI, expression: IExpression }[]\n\t) {\n\t\tthis.globalExpression = parse(globalExpression);\n\t\tfor (const expression of rootExpressions) {\n\t\t\tthis.expressionsByRoot.set(expression.root.toString(), { root: expression.root, expression: parse(expression.expression) });\n\t\t}\n\t}\n\n\tmatches(resource: URI): boolean {\n\t\tconst rootExpression = this.expressionsByRoot.findSubstr(resource.toString());\n\t\tif (rootExpression) {\n\t\t\tconst path = relativePath(rootExpression.root, resource);\n\t\t\tif (path && !!rootExpression.expression(path)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn !!this.globalExpression(resource.path);\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: Schemas.vscodeRemote, authority, path });\n\t}\n\n\treturn resource.with({ scheme: Schemas.file });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMirrorModel, IWorkerContext } from 'vs/editor/common/services/editorSimpleWorker';\nimport { ILink } from 'vs/editor/common/modes';\nimport { URI } from 'vs/base/common/uri';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as resources from 'vs/base/common/resources';\nimport * as strings from 'vs/base/common/strings';\nimport { Range } from 'vs/editor/common/core/range';\nimport { isWindows } from 'vs/base/common/platform';\nimport { Schemas } from 'vs/base/common/network';\nimport { find } from 'vs/base/common/arrays';\n\nexport interface ICreateData {\n\tworkspaceFolders: string[];\n}\n\nexport interface IResourceCreator {\n\ttoResource: (folderRelativePath: string) => URI | null;\n}\n\nexport class OutputLinkComputer {\n\tprivate patterns = new Map<URI /* folder uri */, RegExp[]>();\n\n\tconstructor(private ctx: IWorkerContext, createData: ICreateData) {\n\t\tthis.computePatterns(createData);\n\t}\n\n\tprivate computePatterns(createData: ICreateData): void {\n\n\t\t// Produce patterns for each workspace root we are configured with\n\t\t// This means that we will be able to detect links for paths that\n\t\t// contain any of the workspace roots as segments.\n\t\tconst workspaceFolders = createData.workspaceFolders\n\t\t\t.sort((resourceStrA, resourceStrB) => resourceStrB.length - resourceStrA.length) // longest paths first (for https://github.com/microsoft/vscode/issues/88121)\n\t\t\t.map(resourceStr => URI.parse(resourceStr));\n\n\t\tfor (const workspaceFolder of workspaceFolders) {\n\t\t\tconst patterns = OutputLinkComputer.createPatterns(workspaceFolder);\n\t\t\tthis.patterns.set(workspaceFolder, patterns);\n\t\t}\n\t}\n\n\tprivate getModel(uri: string): IMirrorModel | undefined {\n\t\tconst models = this.ctx.getMirrorModels();\n\n\t\treturn find(models, model => model.uri.toString() === uri);\n\t}\n\n\tcomputeLinks(uri: string): ILink[] {\n\t\tconst model = this.getModel(uri);\n\t\tif (!model) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst links: ILink[] = [];\n\t\tconst lines = model.getValue().split(/\\r\\n|\\r|\\n/);\n\n\t\t// For each workspace root patterns\n\t\tfor (const [folderUri, folderPatterns] of this.patterns) {\n\t\t\tconst resourceCreator: IResourceCreator = {\n\t\t\t\ttoResource: (folderRelativePath: string): URI | null => {\n\t\t\t\t\tif (typeof folderRelativePath === 'string') {\n\t\t\t\t\t\treturn resources.joinPath(folderUri, folderRelativePath);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\t\tlinks.push(...OutputLinkComputer.detectLinks(lines[i], i + 1, folderPatterns, resourceCreator));\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n\n\tstatic createPatterns(workspaceFolder: URI): RegExp[] {\n\t\tconst patterns: RegExp[] = [];\n\n\t\tconst workspaceFolderPath = workspaceFolder.scheme === Schemas.file ? workspaceFolder.fsPath : workspaceFolder.path;\n\t\tconst workspaceFolderVariants = [workspaceFolderPath];\n\t\tif (isWindows && workspaceFolder.scheme === Schemas.file) {\n\t\t\tworkspaceFolderVariants.push(extpath.toSlashes(workspaceFolderPath));\n\t\t}\n\n\t\tfor (const workspaceFolderVariant of workspaceFolderVariants) {\n\t\t\tconst validPathCharacterPattern = '[^\\\\s\\\\(\\\\):<>\"]';\n\t\t\tconst validPathCharacterOrSpacePattern = `(?:${validPathCharacterPattern}| ${validPathCharacterPattern})`;\n\t\t\tconst pathPattern = `${validPathCharacterOrSpacePattern}+\\\\.${validPathCharacterPattern}+`;\n\t\t\tconst strictPathPattern = `${validPathCharacterPattern}+`;\n\n\t\t\t// Example: /workspaces/express/server.js on line 8, column 13\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern}) on line ((\\\\d+)(, column (\\\\d+))?)`, 'gi'));\n\n\t\t\t// Example: /workspaces/express/server.js:line 8, column 13\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern}):line ((\\\\d+)(, column (\\\\d+))?)`, 'gi'));\n\n\t\t\t// Example: /workspaces/mankala/Features.ts(45): error\n\t\t\t// Example: /workspaces/mankala/Features.ts (45): error\n\t\t\t// Example: /workspaces/mankala/Features.ts(45,18): error\n\t\t\t// Example: /workspaces/mankala/Features.ts (45,18): error\n\t\t\t// Example: /workspaces/mankala/Features Special.ts (45,18): error\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern})(\\\\s?\\\\((\\\\d+)(,(\\\\d+))?)\\\\)`, 'gi'));\n\n\t\t\t// Example: at /workspaces/mankala/Game.ts\n\t\t\t// Example: at /workspaces/mankala/Game.ts:336\n\t\t\t// Example: at /workspaces/mankala/Game.ts:336:9\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${strictPathPattern})(:(\\\\d+))?(:(\\\\d+))?`, 'gi'));\n\t\t}\n\n\t\treturn patterns;\n\t}\n\n\t/**\n\t * Detect links. Made static to allow for tests.\n\t */\n\tstatic detectLinks(line: string, lineIndex: number, patterns: RegExp[], resourceCreator: IResourceCreator): ILink[] {\n\t\tconst links: ILink[] = [];\n\n\t\tpatterns.forEach(pattern => {\n\t\t\tpattern.lastIndex = 0; // the holy grail of software development\n\n\t\t\tlet match: RegExpExecArray | null;\n\t\t\tlet offset = 0;\n\t\t\twhile ((match = pattern.exec(line)) !== null) {\n\n\t\t\t\t// Convert the relative path information to a resource that we can use in links\n\t\t\t\tconst folderRelativePath = strings.rtrim(match[1], '.').replace(/\\\\/g, '/'); // remove trailing \".\" that likely indicate end of sentence\n\t\t\t\tlet resourceString: string | undefined;\n\t\t\t\ttry {\n\t\t\t\t\tconst resource = resourceCreator.toResource(folderRelativePath);\n\t\t\t\t\tif (resource) {\n\t\t\t\t\t\tresourceString = resource.toString();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tcontinue; // we might find an invalid URI and then we dont want to loose all other links\n\t\t\t\t}\n\n\t\t\t\t// Append line/col information to URI if matching\n\t\t\t\tif (match[3]) {\n\t\t\t\t\tconst lineNumber = match[3];\n\n\t\t\t\t\tif (match[5]) {\n\t\t\t\t\t\tconst columnNumber = match[5];\n\t\t\t\t\t\tresourceString = strings.format('{0}#{1},{2}', resourceString, lineNumber, columnNumber);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresourceString = strings.format('{0}#{1}', resourceString, lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst fullMatch = strings.rtrim(match[0], '.'); // remove trailing \".\" that likely indicate end of sentence\n\n\t\t\t\tconst index = line.indexOf(fullMatch, offset);\n\t\t\t\toffset += index + fullMatch.length;\n\n\t\t\t\tconst linkRange = {\n\t\t\t\t\tstartColumn: index + 1,\n\t\t\t\t\tstartLineNumber: lineIndex,\n\t\t\t\t\tendColumn: index + 1 + fullMatch.length,\n\t\t\t\t\tendLineNumber: lineIndex\n\t\t\t\t};\n\n\t\t\t\tif (links.some(link => Range.areIntersectingOrTouching(link.range, linkRange))) {\n\t\t\t\t\treturn; // Do not detect duplicate links\n\t\t\t\t}\n\n\t\t\t\tlinks.push({\n\t\t\t\t\trange: linkRange,\n\t\t\t\t\turl: resourceString\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn links;\n\t}\n}\n\nexport function create(ctx: IWorkerContext, createData: ICreateData): OutputLinkComputer {\n\treturn new OutputLinkComputer(ctx, createData);\n}\n"]}